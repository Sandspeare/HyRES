{
 "cpp": {
  "0x3fbc": "unsigned __int64 __fastcall sub_3FBC(const char *a1)\n{\n  char *v1; // rax\n  FILE *v2; // rbx\n  char *v3; // rax\n  char *v4; // rax\n  const char *v5; // rbx\n  char *v6; // rax\n  const char *v8; // [rsp+18h] [rbp-A8h]\n  mystruct_1 *i; // [rsp+20h] [rbp-A0h]\n  const char *v10; // [rsp+28h] [rbp-98h]\n  __int64 v11[15]; // [rsp+30h] [rbp-90h] BYREF\n  unsigned __int64 v12; // [rsp+A8h] [rbp-18h]\n\n  v12 = __readfsqword(0x28u);\n  v11[0] = (__int64)\"[\";\n  v11[1] = (__int64)\"test invocation\";\n  v11[2] = (__int64)\"coreutils\";\n  v11[3] = (__int64)\"Multi-call invocation\";\n  v11[4] = (__int64)\"sha224sum\";\n  v11[5] = (__int64)\"sha2 utilities\";\n  v11[6] = (__int64)\"sha256sum\";\n  v11[7] = (__int64)\"sha2 utilities\";\n  v11[8] = (__int64)\"sha384sum\";\n  v11[9] = (__int64)\"sha2 utilities\";\n  v11[10] = (__int64)\"sha512sum\";\n  v11[11] = (__int64)\"sha2 utilities\";\n  v11[12] = 0LL;\n  v11[13] = 0LL;\n  v8 = a1;\n  for ( i = (mystruct_1 *)v11;\n        *(_QWORD *)&i->mem1_0 && strcmp(a1, *(const char **)&i->mem1_0);\n        i = (mystruct_1 *)((char *)i + 16) )\n  {\n    ;\n  }\n  if ( *(_QWORD *)&i->mem1_8 )\n    v8 = *(const char **)&i->mem1_8;\n  v1 = gettext(\"\\n%s online help: <%s>\\n\");\n  printf(v1, \"GNU coreutils\", \"https://www.gnu.org/software/coreutils/\");\n  v10 = setlocale(5, 0LL);\n  if ( v10 && strncmp(v10, \"en_\", 3uLL) )\n  {\n    v2 = stdout;\n    v3 = gettext(\"Report any translation bugs to <https://translationproject.org/team/>\\n\");\n    fputs_unlocked(v3, v2);\n  }\n  v4 = gettext(\"Full documentation <%s%s>\\n\");\n  printf(v4, \"https://www.gnu.org/software/coreutils/\", a1);\n  if ( v8 == a1 )\n    v5 = \" invocation\";\n  else\n    v5 = locale;\n  v6 = gettext(\"or available locally via: info '(coreutils) %s%s'\\n\");\n  printf(v6, v8, v5);\n  return v12 - __readfsqword(0x28u);\n}\n",
  "0x450d": "__int64 __fastcall sub_450D(char *a1, __int64 a2, mystruct_2 *a3, mystruct_1 *a4)\n{\n  size_t v4; // rax\n  unsigned __int64 v5; // rax\n  void *v6; // rsp\n  __int64 v7; // rdx\n  __int64 v8; // rdx\n  __int64 *v9; // r12\n  char *v10; // rbx\n  int *v11; // rax\n  __int64 *v13; // r12\n  char *v14; // rbx\n  int *v15; // rax\n  __int64 *v16; // r12\n  char *v17; // rbx\n  int *v18; // rax\n  mystruct_1 *v19; // [rsp+8h] [rbp-A0h] BYREF\n  mystruct_2 *v20; // [rsp+10h] [rbp-98h]\n  __int64 v21; // [rsp+18h] [rbp-90h]\n  char *v22; // [rsp+20h] [rbp-88h]\n  int v23; // [rsp+34h] [rbp-74h]\n  mystruct_2 *i; // [rsp+38h] [rbp-70h]\n  char *s; // [rsp+40h] [rbp-68h]\n  size_t n; // [rsp+48h] [rbp-60h]\n  void *dest; // [rsp+50h] [rbp-58h]\n  char *file; // [rsp+58h] [rbp-50h]\n  char *v29; // [rsp+60h] [rbp-48h]\n  __int64 v30[8]; // [rsp+68h] [rbp-40h] BYREF\n\n  v22 = a1;\n  v21 = a2;\n  v20 = a3;\n  v19 = a4;\n  v30[5] = __readfsqword(0x28u);\n  s = a1;\n  v4 = strlen(a1);\n  n = v4 + 1;\n  v5 = 16 * ((v4 + 24) / 0x10);\n  while ( &v19 != (mystruct_1 **)((char *)&v19 - (v5 & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v6 = alloca(v5 & 0xFFF);\n  if ( (v5 & 0xFFF) != 0 )\n    *(mystruct_1 **)((char *)&v19 + (v5 & 0xFFF) - 8) = *(mystruct_1 **)((char *)&v19 + (v5 & 0xFFF) - 8);\n  dest = &v19;\n  file = (char *)memcpy(&v19, s, n);\n  v29 = &file[v21];\n  for ( i = v20; i; i = *(mystruct_2 **)&i->mem2_160 )\n  {\n    file[*(_QWORD *)&i->mem2_152] = 0;\n    if ( v19->mem1_31 )\n    {\n      v30[0] = sub_14E7E((__int64)i);\n      v30[1] = v7;\n      v30[2] = sub_14EB2((__int64)i);\n      v30[3] = v8;\n      if ( sub_16669(file, v30) )\n      {\n        v9 = sub_13BE4(4u, (__int64)file);\n        v10 = gettext(\"failed to preserve times for %s\");\n        v11 = __errno_location();\n        error(0, *v11, v10, v9);\n        return 0LL;\n      }\n    }\n    if ( v19->mem1_29 && lchown(file, *(_DWORD *)&i->mem2_28, *(_DWORD *)&i->mem2_32) )\n    {\n      if ( !sub_D236((__int64)v19) )\n      {\n        v13 = sub_13BE4(4u, (__int64)file);\n        v14 = gettext(\"failed to preserve ownership for %s\");\n        v15 = __errno_location();\n        error(0, *v15, v14, v13);\n        return 0LL;\n      }\n      v23 = lchown(file, 0xFFFFFFFF, *(_DWORD *)&i->mem2_32);\n    }\n    if ( v19->mem1_30 )\n    {\n      if ( (unsigned int)sub_E265((__int64)v29, 0xFFFFFFFF, (__int64)file, 0xFFFFFFFF, *(_DWORD *)&i->mem2_24) )\n        return 0LL;\n    }\n    else if ( i->mem2_144 && lchmod(file, *(_DWORD *)&i->mem2_24) )\n    {\n      v16 = sub_13BE4(4u, (__int64)file);\n      v17 = gettext(\"failed to preserve permissions for %s\");\n      v18 = __errno_location();\n      error(0, *v18, v17, v16);\n      return 0LL;\n    }\n    file[*(_QWORD *)&i->mem2_152] = 47;\n  }\n  return 1LL;\n}\n",
  "0x489b": "__int64 __fastcall sub_489B(char *a1, __int64 a2, char *a3, __dev_t **a4, _BYTE *a5, mystruct_2 *a6)\n{\n  size_t v6; // rax\n  unsigned __int64 v7; // rax\n  void *v8; // rsp\n  size_t v9; // rax\n  void *v10; // rsp\n  int v11; // eax\n  int v12; // eax\n  __int64 *v13; // rbx\n  char *v14; // rax\n  mystruct_1 *v16; // rax\n  __ino_t st_ino; // rbx\n  __int64 v18; // rbx\n  __dev_t st_rdev; // rbx\n  __blksize_t st_blksize; // rbx\n  __time_t tv_sec; // rbx\n  __time_t v22; // rbx\n  __time_t v23; // rbx\n  __syscall_slong_t v24; // rbx\n  __syscall_slong_t v25; // rbx\n  unsigned int v26; // eax\n  int v27; // eax\n  __int16 v28; // ax\n  __int64 *v29; // r12\n  char *v30; // rbx\n  int *v31; // rax\n  __int64 *v32; // r12\n  char *v33; // rbx\n  int *v34; // rax\n  __int64 *v35; // r12\n  char *v36; // rbx\n  int *v37; // rax\n  __int64 *v38; // rbx\n  char *v39; // rax\n  char *v40; // rax\n  __int64 *v41; // rbx\n  char *v42; // rax\n  mystruct_2 *v43; // [rsp+8h] [rbp-1D0h] BYREF\n  _BYTE *v44; // [rsp+10h] [rbp-1C8h]\n  __dev_t **v45; // [rsp+18h] [rbp-1C0h]\n  char *format; // [rsp+20h] [rbp-1B8h]\n  __int64 v47; // [rsp+28h] [rbp-1B0h]\n  char *v48; // [rsp+30h] [rbp-1A8h]\n  bool v49; // [rsp+3Fh] [rbp-199h]\n  int v50; // [rsp+40h] [rbp-198h]\n  int errnum; // [rsp+44h] [rbp-194h]\n  int v52; // [rsp+48h] [rbp-190h]\n  __mode_t mode; // [rsp+4Ch] [rbp-18Ch]\n  char *i; // [rsp+50h] [rbp-188h]\n  mystruct_3 *v55; // [rsp+58h] [rbp-180h]\n  char *s; // [rsp+60h] [rbp-178h]\n  size_t n; // [rsp+68h] [rbp-170h]\n  void *dest; // [rsp+70h] [rbp-168h]\n  void *src; // [rsp+78h] [rbp-160h]\n  char *v60; // [rsp+80h] [rbp-158h]\n  size_t v61; // [rsp+88h] [rbp-150h]\n  char *file; // [rsp+90h] [rbp-148h]\n  struct stat v63; // [rsp+98h] [rbp-140h] BYREF\n  struct stat v64; // [rsp+128h] [rbp-B0h] BYREF\n  unsigned __int64 v65; // [rsp+1C0h] [rbp-18h]\n\n  v48 = a1;\n  v47 = a2;\n  format = a3;\n  v45 = a4;\n  v44 = a5;\n  v43 = a6;\n  v65 = __readfsqword(0x28u);\n  s = a1;\n  v6 = strlen(a1);\n  n = v6 + 1;\n  v7 = 16 * ((v6 + 24) / 0x10);\n  while ( &v43 != (mystruct_2 **)((char *)&v43 - (v7 & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v8 = alloca(v7 & 0xFFF);\n  if ( (v7 & 0xFFF) != 0 )\n    *(mystruct_2 **)((char *)&v43 + (v7 & 0xFFF) - 8) = *(mystruct_2 **)((char *)&v43 + (v7 & 0xFFF) - 8);\n  dest = &v43;\n  src = memcpy(&v43, s, n);\n  v60 = (char *)src + v47;\n  v61 = sub_F899(src);\n  v9 = 16 * ((v61 + 24) / 0x10);\n  while ( &v43 != (mystruct_2 **)((char *)&v43 - (v9 & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v10 = alloca(v9 & 0xFFF);\n  if ( (v9 & 0xFFF) != 0 )\n    *(mystruct_2 **)((char *)&v43 + (v9 & 0xFFF) - 8) = *(mystruct_2 **)((char *)&v43 + (v9 & 0xFFF) - 8);\n  file = (char *)&v43;\n  memcpy(&v43, src, v61);\n  file[v61] = 0;\n  *v45 = 0LL;\n  if ( stat(file, &v63) )\n  {\n    for ( i = v60; *i == 47; ++i )\n      ;\n    while ( 1 )\n    {\n      i = strchr(i, 47);\n      if ( !i )\n        break;\n      *i = 0;\n      v11 = stat((const char *)src, &v63);\n      v49 = v11 != 0;\n      if ( v11 || v43->mem2_29 || v43->mem2_30 || v43->mem2_31 )\n      {\n        if ( stat(v60, &v64) )\n        {\n          v12 = *__errno_location();\n        }\n        else if ( (v64.st_mode & 0xF000) == 0x4000 )\n        {\n          v12 = 0;\n        }\n        else\n        {\n          v12 = 20;\n        }\n        errnum = v12;\n        if ( v12 )\n        {\n          v13 = sub_13BE4(4u, (__int64)v60);\n          v14 = gettext(\"failed to get attributes of %s\");\n          error(0, errnum, v14, v13);\n          return 0LL;\n        }\n        v16 = (mystruct_1 *)sub_1745E(0xA8uLL, (__int64)&v64);\n        v55 = (mystruct_3 *)v16;\n        st_ino = v64.st_ino;\n        *(_QWORD *)&v16->mem1_0 = v64.st_dev;\n        *(_QWORD *)&v16->mem1_8 = st_ino;\n        v18 = *(_QWORD *)&v64.st_mode;\n        *(_QWORD *)&v16->mem1_16 = v64.st_nlink;\n        *(_QWORD *)&v16->mem1_24 = v18;\n        st_rdev = v64.st_rdev;\n        *(_QWORD *)&v16->mem1_32 = *(_QWORD *)&v64.st_gid;\n        *(_QWORD *)&v16->mem1_40 = st_rdev;\n        st_blksize = v64.st_blksize;\n        *(_QWORD *)&v16->mem1_48 = v64.st_size;\n        *(_QWORD *)&v16->mem1_56 = st_blksize;\n        tv_sec = v64.st_atim.tv_sec;\n        *(_QWORD *)&v16->mem1_64 = v64.st_blocks;\n        *(_QWORD *)&v16->mem1_72 = tv_sec;\n        v22 = v64.st_mtim.tv_sec;\n        *(_QWORD *)&v16->mem1_80 = v64.st_atim.tv_nsec;\n        *(_QWORD *)&v16->mem1_88 = v22;\n        v23 = v64.st_ctim.tv_sec;\n        *(_QWORD *)&v16->mem1_96 = v64.st_mtim.tv_nsec;\n        *(_QWORD *)&v16->mem1_104 = v23;\n        v24 = v64.__unused[0];\n        *(_QWORD *)&v16->mem1_112 = v64.st_ctim.tv_nsec;\n        *(_QWORD *)&v16->mem1_120 = v24;\n        v25 = v64.__unused[2];\n        *(_QWORD *)&v16->mem1_128 = v64.__unused[1];\n        *(_QWORD *)&v16->mem1_136 = v25;\n        *(_QWORD *)&v55->mem3_152 = i - (_BYTE *)src;\n        v55->mem3_144 = 0;\n        *(_QWORD *)&v55->mem3_160 = *v45;\n        *v45 = (__dev_t *)v55;\n      }\n      if ( v49 )\n        v26 = *(_DWORD *)&v55->mem3_24;\n      else\n        v26 = 0;\n      if ( (unsigned __int8)sub_7F19((__int64)v60, (__int64)src, v26, v49, v43) != 1 )\n        return 0LL;\n      if ( v49 )\n      {\n        *v44 = 1;\n        v52 = *(_DWORD *)&v55->mem3_24;\n        if ( v43->mem2_29 != 1 )\n        {\n          if ( v43->mem2_30 )\n            v27 = 18;\n          else\n            v27 = 0;\n        }\n        else\n        {\n          v27 = 63;\n        }\n        v50 = v52 & v27;\n        if ( v43->mem2_32 )\n          v28 = 511;\n        else\n          v28 = v52;\n        mode = (unsigned __int16)v28 & (unsigned __int16)~(_WORD)v50 & 0xFFF;\n        if ( mkdir((const char *)src, mode) )\n        {\n          v29 = sub_13BE4(4u, (__int64)src);\n          v30 = gettext(\"cannot make directory %s\");\n          v31 = __errno_location();\n          error(0, *v31, v30, v29);\n          return 0LL;\n        }\n        if ( format )\n          printf(format, v60, src);\n        if ( lstat((const char *)src, &v63) )\n        {\n          v32 = sub_13BE4(4u, (__int64)src);\n          v33 = gettext(\"failed to get attributes of %s\");\n          v34 = __errno_location();\n          error(0, *v34, v33, v32);\n          return 0LL;\n        }\n        if ( v43->mem2_30 != 1 )\n        {\n          if ( (v50 & ~v63.st_mode) != 0 )\n            v50 &= ~(unsigned int)sub_D2C6();\n          if ( (v50 & ~v63.st_mode) != 0 || (v63.st_mode & 0x1C0) != 448 )\n          {\n            *(_DWORD *)&v55->mem3_24 = v50 | v63.st_mode;\n            v55->mem3_144 = 1;\n          }\n        }\n        if ( (v63.st_mode & 0x1C0) != 448 && lchmod((const char *)src, v63.st_mode | 0x1C0) )\n        {\n          v35 = sub_13BE4(4u, (__int64)src);\n          v36 = gettext(\"setting permissions for %s\");\n          v37 = __errno_location();\n          error(0, *v37, v36, v35);\n          return 0LL;\n        }\n      }\n      else\n      {\n        if ( (v63.st_mode & 0xF000) != 0x4000 )\n        {\n          v38 = sub_13BE4(4u, (__int64)src);\n          v39 = gettext(\"%s exists but is not a directory\");\n          error(0, 0, v39, v38);\n          return 0LL;\n        }\n        *v44 = 0;\n      }\n      if ( *v44 != 1\n        && (v43->mem2_33 || v43->mem2_37)\n        && (unsigned __int8)sub_8199((__int64)src, v43->mem2_37, 0, v43) != 1\n        && v43->mem2_38 )\n      {\n        return 0LL;\n      }\n      v40 = i++;\n      *v40 = 47;\n      while ( *i == 47 )\n        ++i;\n    }\n  }\n  else\n  {\n    if ( (v63.st_mode & 0xF000) != 0x4000 )\n    {\n      v41 = sub_13BE4(4u, (__int64)file);\n      v42 = gettext(\"%s exists but is not a directory\");\n      error(0, 0, v42, v41);\n      return 0LL;\n    }\n    *v44 = 0;\n  }\n  return 1LL;\n}\n",
  "0x52d5": "_BOOL8 __fastcall sub_52D5(int a1, mystruct_3 *a2, const char *a3, char a4, mystruct_1 *a5)\n{\n  char *v5; // rax\n  __int64 *v6; // rbx\n  char *v7; // rax\n  char *v8; // rax\n  __int64 *v9; // rbx\n  char *v10; // rax\n  __int64 *v11; // rbx\n  char *v12; // rax\n  size_t v13; // rax\n  unsigned __int64 v14; // rax\n  void *v15; // rsp\n  char *v16; // rdx\n  size_t v17; // rax\n  unsigned __int64 v18; // rax\n  void *v19; // rsp\n  void *v20; // rax\n  unsigned __int8 v21; // al\n  unsigned __int8 v22; // al\n  char *v23; // rax\n  __int64 v24; // rbx\n  __int64 v25; // rbx\n  __int64 v26; // rbx\n  __int64 v27; // rbx\n  __int64 v28; // rdx\n  mystruct_2 *v30; // [rsp+8h] [rbp-160h] BYREF\n  const char *v31; // [rsp+10h] [rbp-158h]\n  mystruct_3 *v32; // [rsp+18h] [rbp-150h]\n  char v33; // [rsp+20h] [rbp-148h]\n  int v34; // [rsp+24h] [rbp-144h]\n  bool v35; // [rsp+2Eh] [rbp-13Ah] BYREF\n  bool v36; // [rsp+2Fh] [rbp-139h] BYREF\n  bool v37; // [rsp+30h] [rbp-138h]\n  char v38; // [rsp+31h] [rbp-137h]\n  bool v39; // [rsp+32h] [rbp-136h]\n  bool v40; // [rsp+33h] [rbp-135h]\n  int i; // [rsp+34h] [rbp-134h]\n  mystruct_4 *v42; // [rsp+38h] [rbp-130h] BYREF\n  __int64 v43; // [rsp+40h] [rbp-128h] BYREF\n  void *v44; // [rsp+48h] [rbp-120h]\n  char *v45; // [rsp+50h] [rbp-118h]\n  char *v46; // [rsp+58h] [rbp-110h]\n  char *s2; // [rsp+60h] [rbp-108h]\n  char *v48; // [rsp+68h] [rbp-100h]\n  char *v49; // [rsp+70h] [rbp-F8h]\n  size_t v50; // [rsp+78h] [rbp-F0h]\n  void *v51; // [rsp+80h] [rbp-E8h]\n  char *s1; // [rsp+88h] [rbp-E0h]\n  char *s; // [rsp+90h] [rbp-D8h]\n  size_t n; // [rsp+98h] [rbp-D0h]\n  void *dest; // [rsp+A0h] [rbp-C8h]\n  char *v56; // [rsp+A8h] [rbp-C0h]\n  void *ptr; // [rsp+B0h] [rbp-B8h]\n  struct stat v58; // [rsp+B8h] [rbp-B0h] BYREF\n  unsigned __int64 v59; // [rsp+150h] [rbp-18h]\n\n  v34 = a1;\n  v32 = a2;\n  v31 = a3;\n  v30 = (mystruct_2 *)a5;\n  v33 = a4;\n  v59 = __readfsqword(0x28u);\n  v35 = 0;\n  v37 = 1;\n  v39 = *(_WORD *)&a5->mem1_21 != 0;\n  if ( a1 <= (a3 == 0LL) )\n  {\n    if ( v34 > 0 )\n    {\n      v6 = sub_13BE4(4u, *(_QWORD *)&v32->mem3_0);\n      v7 = gettext(\"missing destination file operand after %s\");\n      error(0, 0, v7, v6);\n    }\n    else\n    {\n      v5 = gettext(\"missing file operand\");\n      error(0, 0, v5);\n    }\n    sub_422D(1);\n  }\n  if ( v33 )\n  {\n    if ( v31 )\n    {\n      v8 = gettext(\"cannot combine --target-directory (-t) and --no-target-directory (-T)\");\n      error(1, 0, v8);\n    }\n    if ( v34 > 2 )\n    {\n      v9 = sub_13BE4(4u, *(_QWORD *)&v32->mem3_16);\n      v10 = gettext(\"extra operand %s\");\n      error(0, 0, v10, v9);\n      sub_422D(1);\n    }\n    v40 = sub_51F4(*((const char **)v32 + v34 - 1), &v58, &v35, v39);\n  }\n  else if ( !v31 )\n  {\n    if ( v34 > 1 && sub_51F4(*((const char **)v32 + v34 - 1), &v58, &v35, v39) )\n    {\n      v31 = (const char *)*((_QWORD *)&v32->mem3_0 + --v34);\n    }\n    else if ( v34 > 2 )\n    {\n      v11 = sub_13BE4(4u, *((_QWORD *)v32 + v34 - 1));\n      v12 = gettext(\"target %s is not a directory\");\n      error(1, 0, v12, v11);\n    }\n  }\n  if ( v31 )\n  {\n    if ( v34 > 1 )\n    {\n      sub_9E5C((__int64)v30);\n      sub_9EA4((__int64)v30);\n    }\n    for ( i = 0; i < v34; ++i )\n    {\n      v38 = 1;\n      v43 = 0LL;\n      v48 = (char *)*((_QWORD *)&v32->mem3_0 + i);\n      if ( byte_24122 )\n        sub_FA79(v48);\n      if ( byte_24121 )\n      {\n        s = v48;\n        v13 = strlen(v48);\n        n = v13 + 1;\n        v14 = 16 * ((v13 + 24) / 0x10);\n        while ( &v30 != (mystruct_2 **)((char *)&v30 - (v14 & 0xFFFFFFFFFFFFF000LL)) )\n          ;\n        v15 = alloca(v14 & 0xFFF);\n        if ( (v14 & 0xFFF) != 0 )\n          *(mystruct_2 **)((char *)&v30 + (v14 & 0xFFF) - 8) = *(mystruct_2 **)((char *)&v30 + (v14 & 0xFFF) - 8);\n        dest = &v30;\n        v56 = (char *)memcpy(&v30, s, n);\n        sub_FA79(v56);\n        v44 = (void *)sub_10059((__int64)v31, (__int64)v56, (__int64)&v43);\n        if ( v30->mem2_46 )\n          v16 = \"%s -> %s\\n\";\n        else\n          v16 = 0LL;\n        v38 = sub_489B((char *)v44, v43 - (_QWORD)v44, v16, (__dev_t **)&v42, &v35, v30);\n      }\n      else\n      {\n        v49 = sub_F9B9(v48);\n        v17 = strlen(v49);\n        v50 = v17 + 1;\n        v18 = 16 * ((v17 + 24) / 0x10);\n        while ( &v30 != (mystruct_2 **)((char *)&v30 - (v18 & 0xFFFFFFFFFFFFF000LL)) )\n          ;\n        v19 = alloca(v18 & 0xFFF);\n        if ( (v18 & 0xFFF) != 0 )\n          *(mystruct_2 **)((char *)&v30 + (v18 & 0xFFF) - 8) = *(mystruct_2 **)((char *)&v30 + (v18 & 0xFFF) - 8);\n        v51 = &v30;\n        s1 = (char *)memcpy(&v30, v49, v50);\n        sub_FA79(s1);\n        if ( !strcmp(s1, \"..\") )\n          v20 = sub_175EA(v31);\n        else\n          v20 = (void *)sub_10059((__int64)v31, (__int64)s1, 0LL);\n        v44 = v20;\n      }\n      if ( v38 != 1 )\n      {\n        v37 = 0;\n      }\n      else\n      {\n        v21 = sub_D10F(v48, (char *)v44, v35, v30, &v36, 0LL);\n        v37 = (v37 & v21) != 0;\n        if ( byte_24121 )\n        {\n          v22 = sub_450D((char *)v44, v43 - (_QWORD)v44, (mystruct_2 *)v42, (mystruct_1 *)v30);\n          v37 = (v37 & v22) != 0;\n        }\n      }\n      if ( byte_24121 )\n      {\n        while ( v42 )\n        {\n          ptr = v42;\n          v42 = *(mystruct_4 **)&v42->mem4_160;\n          free(ptr);\n        }\n      }\n      free(v44);\n    }\n  }\n  else\n  {\n    v46 = *(char **)&v32->mem3_0;\n    s2 = *(char **)&v32->mem3_8;\n    if ( byte_24121 )\n    {\n      v23 = gettext(\"with --parents, the destination must be a directory\");\n      error(0, 0, v23);\n      sub_422D(1);\n    }\n    if ( v30->mem2_22 && *(_DWORD *)&v30->mem2_0 && !strcmp(v46, s2) && !v35 && (v58.st_mode & 0xF000) == 0x8000 )\n    {\n      v45 = (char *)sub_F422(0xFFFFFF9C, s2, *(_DWORD *)&v30->mem2_0);\n      v24 = *(_QWORD *)&v30->mem2_8;\n      qword_24140 = *(_QWORD *)&v30->mem2_0;\n      qword_24148 = v24;\n      v25 = *(_QWORD *)&v30->mem2_24;\n      qword_24150 = *(_QWORD *)&v30->mem2_16;\n      qword_24158 = v25;\n      v26 = *(_QWORD *)&v30->mem2_40;\n      qword_24160 = *(_QWORD *)&v30->mem2_32;\n      qword_24168 = v26;\n      v27 = *(_QWORD *)&v30->mem2_56;\n      qword_24170 = *(_QWORD *)&v30->mem2_48;\n      qword_24178 = v27;\n      v28 = *(_QWORD *)&v30->mem2_72;\n      qword_24180 = *(_QWORD *)&v30->mem2_64;\n      qword_24188 = v28;\n      LODWORD(qword_24140) = 0;\n      v30 = (mystruct_2 *)&qword_24140;\n    }\n    else\n    {\n      v45 = s2;\n    }\n    return (bool)sub_D10F(v46, v45, 0, v30, (bool *)&v43, 0LL);\n  }\n  return v37;\n}\n",
  "0x5c29": "mystruct_1 *__fastcall sub_5C29(mystruct_1 *a1)\n{\n  mystruct_1 *result; // rax\n\n  sub_D1E2((__int64)a1);\n  a1->mem1_20 = 1;\n  *(_DWORD *)&a1->mem1_4 = 1;\n  a1->mem1_21 = 0;\n  a1->mem1_22 = 0;\n  a1->mem1_23 = 0;\n  *(_DWORD *)&a1->mem1_8 = 4;\n  a1->mem1_24 = 0;\n  a1->mem1_25 = 0;\n  a1->mem1_28 = 0;\n  *(_DWORD *)&a1->mem1_56 = 0;\n  a1->mem1_29 = 0;\n  a1->mem1_34 = 0;\n  a1->mem1_30 = 0;\n  a1->mem1_31 = 0;\n  a1->mem1_32 = 0;\n  a1->mem1_37 = 0;\n  a1->mem1_38 = 0;\n  a1->mem1_33 = 0;\n  a1->mem1_39 = 0;\n  a1->mem1_41 = 0;\n  a1->mem1_40 = 0;\n  a1->mem1_35 = 1;\n  a1->mem1_36 = 0;\n  a1->mem1_42 = 0;\n  *(_DWORD *)&a1->mem1_12 = 2;\n  a1->mem1_44 = 0;\n  a1->mem1_43 = 0;\n  *(_DWORD *)&a1->mem1_16 = 0;\n  a1->mem1_47 = 0;\n  a1->mem1_45 = 0;\n  a1->mem1_46 = 0;\n  a1->mem1_48 = getenv(\"POSIXLY_CORRECT\") != 0LL;\n  *(_QWORD *)&a1->mem1_64 = 0LL;\n  result = a1;\n  *(_QWORD *)&a1->mem1_72 = 0LL;\n  return result;\n}\n",
  "0x5d83": "void __fastcall sub_5D83(const char *a1, mystruct_1 *a2, char a3)\n{\n  char *v3; // rax\n  const char *v4; // rax\n  char *s; // [rsp+28h] [rbp-18h]\n  char *v7; // [rsp+30h] [rbp-10h]\n  char *ptr; // [rsp+38h] [rbp-8h]\n\n  ptr = (char *)sub_175EA(a1);\n  s = ptr;\n  do\n  {\n    v7 = strchr(s, 44);\n    if ( v7 )\n    {\n      v3 = v7++;\n      *v3 = 0;\n    }\n    if ( a3 )\n      v4 = \"--preserve\";\n    else\n      v4 = \"--no-preserve\";\n    switch ( sub_E9CF((__int64)v4, s, (__int64)off_23920, (__int64)&unk_1CB90, 4uLL, (void (*)(void))off_24028) )\n    {\n      case 0LL:\n      case 7LL:\n        a2->mem1_30 = a3;\n        a2->mem1_32 = a3 == 0;\n        break;\n      case 1LL:\n        a2->mem1_31 = a3;\n        break;\n      case 2LL:\n        a2->mem1_29 = a3;\n        break;\n      case 3LL:\n        a2->mem1_34 = a3;\n        break;\n      case 4LL:\n        a2->mem1_38 = a3;\n        a2->mem1_37 = a3;\n        break;\n      case 5LL:\n        a2->mem1_39 = a3;\n        a2->mem1_40 = a3;\n        break;\n      case 6LL:\n        a2->mem1_30 = a3;\n        a2->mem1_31 = a3;\n        a2->mem1_29 = a3;\n        a2->mem1_34 = a3;\n        a2->mem1_32 = a3 == 0;\n        if ( byte_24120 )\n          a2->mem1_37 = a3;\n        a2->mem1_39 = a3;\n        break;\n      default:\n        abort();\n    }\n    s = v7;\n  }\n  while ( v7 );\n  free(ptr);\n}\n",
  "0x6905": "_BOOL8 __fastcall sub_6905(mystruct_1 *a1)\n{\n  __int64 v1; // rdx\n  char v4; // [rsp+17h] [rbp-1h]\n\n  if ( a1->mem1_0 != 46 )\n    return 0LL;\n  if ( a1->mem1_1 == 46 )\n    v1 = 2LL;\n  else\n    v1 = 1LL;\n  v4 = *(&a1->mem1_0 + v1);\n  return !v4 || v4 == 47;\n}\n",
  "0x6a62": "mystruct_1 *__fastcall sub_6A62(mystruct_1 *a1)\n{\n  mystruct_1 *result; // rax\n\n  free(*(void **)&a1->mem1_40);\n  *(_QWORD *)&a1->mem1_40 = 0LL;\n  result = a1;\n  *(_QWORD *)&a1->mem1_24 = 0LL;\n  return result;\n}\n",
  "0x78e1": "__int64 __fastcall sub_78E1(mystruct_1 *a1, mystruct_2 *a2)\n{\n  while ( a2 )\n  {\n    if ( *(_QWORD *)&a2->mem2_8 == *(_QWORD *)&a1->mem1_8 && *(_QWORD *)&a2->mem2_16 == *(_QWORD *)&a1->mem1_0 )\n      return 1LL;\n    a2 = *(mystruct_2 **)&a2->mem2_0;\n  }\n  return 0LL;\n}\n",
  "0x7985": "_BOOL8 __fastcall sub_7985(__int64 a1, __int64 a2, bool a3, _QWORD *a4, _QWORD *a5, mystruct_1 *a6, bool *a7, bool *a8)\n{\n  __int64 v8; // rbx\n  __int64 v9; // rbx\n  __int64 v10; // rbx\n  __int64 v11; // rbx\n  __int64 v12; // rdx\n  __int64 *v13; // r12\n  char *v14; // rbx\n  int *v15; // rax\n  unsigned __int8 v17; // al\n  size_t v18; // rax\n  bool v23; // [rsp+4Ch] [rbp-94h] BYREF\n  bool v24; // [rsp+4Dh] [rbp-93h] BYREF\n  bool v25; // [rsp+4Eh] [rbp-92h]\n  bool v26; // [rsp+4Fh] [rbp-91h]\n  char *s; // [rsp+50h] [rbp-90h]\n  void *v28; // [rsp+58h] [rbp-88h]\n  void *v29; // [rsp+60h] [rbp-80h]\n  void *ptr; // [rsp+68h] [rbp-78h]\n  __int64 v31[14]; // [rsp+70h] [rbp-70h] BYREF\n\n  v31[11] = __readfsqword(0x28u);\n  v8 = *(_QWORD *)&a6->mem1_8;\n  v31[0] = *(_QWORD *)&a6->mem1_0;\n  v31[1] = v8;\n  v9 = *(_QWORD *)&a6->mem1_24;\n  v31[2] = *(_QWORD *)&a6->mem1_16;\n  v31[3] = v9;\n  v10 = *(_QWORD *)&a6->mem1_40;\n  v31[4] = *(_QWORD *)&a6->mem1_32;\n  v31[5] = v10;\n  v11 = *(_QWORD *)&a6->mem1_56;\n  v31[6] = *(_QWORD *)&a6->mem1_48;\n  v31[7] = v11;\n  v12 = *(_QWORD *)&a6->mem1_72;\n  v31[8] = *(_QWORD *)&a6->mem1_64;\n  v31[9] = v12;\n  v25 = 1;\n  v28 = sub_14B48(a1, 2u);\n  if ( v28 )\n  {\n    if ( *(_DWORD *)&a6->mem1_4 == 3 )\n      HIDWORD(v31[0]) = 2;\n    v26 = 0;\n    for ( s = (char *)v28; *s; s += v18 + 1 )\n    {\n      v29 = (void *)sub_10059(a1, (__int64)s, 0LL);\n      ptr = (void *)sub_10059(a2, (__int64)s, 0LL);\n      v24 = *a7;\n      v17 = sub_A404((char *)v29, (char *)ptr, a3, a4, a5, v31, 0, (char *)&v24, &v23, 0LL);\n      v25 = (v25 & v17) != 0;\n      *a8 = *a8 || v23;\n      free(ptr);\n      free(v29);\n      if ( v23 )\n        break;\n      v26 = v26 || v24;\n      v18 = strlen(s);\n    }\n    free(v28);\n    *a7 = v26;\n    return v25;\n  }\n  else\n  {\n    v13 = sub_13BE4(4u, a1);\n    v14 = gettext(\"cannot access %s\");\n    v15 = __errno_location();\n    error(0, *v15, v14, v13);\n    return 0LL;\n  }\n}\n",
  "0x7c6a": "__int64 __fastcall sub_7C6A(mystruct_2 *a1, const char *a2, unsigned int a3, mystruct_1 *a4, char a5, mystruct_3 *a6)\n{\n  int v6; // eax\n  unsigned __int16 v7; // ax\n  __int64 *v8; // r12\n  char *v9; // rbx\n  int *v10; // rax\n  __int64 *v12; // r12\n  char *v13; // rbx\n  int *v14; // rax\n  __uid_t owner; // [rsp+3Ch] [rbp-34h]\n  __gid_t group; // [rsp+40h] [rbp-30h]\n  int v18; // [rsp+44h] [rbp-2Ch]\n  int v19; // [rsp+4Ch] [rbp-24h]\n  int v20; // [rsp+50h] [rbp-20h]\n  int v21; // [rsp+58h] [rbp-18h]\n\n  owner = *(_DWORD *)&a4->mem1_28;\n  group = *(_DWORD *)&a4->mem1_32;\n  if ( a5 != 1\n    && (a1->mem2_30 || a1->mem2_24 || a1->mem2_43)\n    && ((v18 = *(_DWORD *)&a6->mem3_24, !a1->mem2_30) && !a1->mem2_24\n      ? (v6 = *(_DWORD *)&a1->mem2_16)\n      : (v6 = *(_DWORD *)&a4->mem1_24),\n        (v19 = (unsigned __int16)v6 & (unsigned __int16)v18 & 0x1C0,\n         v7 = ~(_WORD)v6,\n         HIBYTE(v7) |= 0xEu,\n         ((unsigned __int16)v18 & v7 & 0xFFF) != 0)\n     && (unsigned int)sub_12099((__int64)a2, a3, v19)) )\n  {\n    if ( !sub_D27E((__int64)a1) )\n    {\n      v8 = sub_13BE4(4u, (__int64)a2);\n      v9 = gettext(\"clearing permissions for %s\");\n      v10 = __errno_location();\n      error(0, *v10, v9, v8);\n    }\n    return (unsigned int)-(unsigned __int8)a1->mem2_36;\n  }\n  else\n  {\n    if ( a3 == -1 )\n    {\n      if ( !lchown(a2, owner, group) )\n        return 1LL;\n      if ( *__errno_location() == 1 || *__errno_location() == 22 )\n      {\n        v20 = *__errno_location();\n        lchown(a2, 0xFFFFFFFF, group);\n        *__errno_location() = v20;\n      }\n    }\n    else\n    {\n      if ( !fchown(a3, owner, group) )\n        return 1LL;\n      if ( *__errno_location() == 1 || *__errno_location() == 22 )\n      {\n        v21 = *__errno_location();\n        fchown(a3, 0xFFFFFFFF, group);\n        *__errno_location() = v21;\n      }\n    }\n    if ( !sub_D236((__int64)a1)\n      && (v12 = sub_13BE4(4u, (__int64)a2),\n          v13 = gettext(\"failed to preserve ownership for %s\"),\n          v14 = __errno_location(),\n          error(0, *v14, v13, v12),\n          a1->mem2_36) )\n    {\n      return 0xFFFFFFFFLL;\n    }\n    else\n    {\n      return 0LL;\n    }\n  }\n}\n",
  "0x7f19": "__int64 __fastcall sub_7F19(__int64 a1, __int64 a2, unsigned int a3, char a4, mystruct_1 *a5)\n{\n  bool v5; // al\n  bool v6; // al\n  int *v7; // rax\n  __int64 *v8; // r12\n  char *v9; // rbx\n  int *v10; // rax\n  int *v12; // rax\n  __int64 *v13; // r12\n  char *v14; // rbx\n  int *v15; // rax\n  int *v16; // rax\n  __int64 *v17; // r12\n  char *v18; // rbx\n  int *v19; // rax\n  bool v21; // [rsp+2Eh] [rbp-22h]\n  bool v22; // [rsp+2Fh] [rbp-21h]\n  __int64 v23; // [rsp+30h] [rbp-20h]\n\n  if ( a5->mem1_37 )\n  {\n    v5 = a5->mem1_35 != 1 || a5->mem1_38;\n    v21 = v5;\n    v6 = !v5 && a5->mem1_41 != 1;\n    v22 = v6;\n    if ( (int)sub_14C8F() < 0 )\n    {\n      if ( v21 || v22 && (v12 = __errno_location(), !sub_793C(*v12)) )\n      {\n        v13 = sub_13BE4(4u, a1);\n        v14 = gettext(\"failed to get security context of %s\");\n        v15 = __errno_location();\n        error(0, *v15, v14, v13);\n      }\n      if ( a5->mem1_38 )\n        return 0LL;\n    }\n    else\n    {\n      if ( (int)sub_14C1E() < 0 )\n      {\n        if ( v21 || v22 && (v7 = __errno_location(), !sub_793C(*v7)) )\n        {\n          v8 = ZZN6google8protobuf8internal16OnShutdownDeleteINS0_12_GLOBAL__N_113MetadataOwnerEEEPT_S6_ENUlPKvE_4_FUNES8__0(v23);\n          v9 = gettext(\"failed to set default file creation context to %s\");\n          v10 = __errno_location();\n          error(0, *v10, v9, v8);\n        }\n        if ( a5->mem1_38 )\n        {\n          sub_14BED();\n          return 0LL;\n        }\n      }\n      sub_14BED();\n    }\n  }\n  else if ( a5->mem1_33 )\n  {\n    if ( a4 )\n    {\n      if ( (int)sub_6B49(a2, a3) < 0 )\n      {\n        v16 = __errno_location();\n        if ( !sub_6AFB(*v16) )\n        {\n          v17 = sub_13BE4(4u, a2);\n          v18 = gettext(\"failed to set default file creation context for %s\");\n          v19 = __errno_location();\n          error(0, *v19, v18, v17);\n        }\n      }\n    }\n  }\n  return 1LL;\n}\n",
  "0x8199": "__int64 __fastcall sub_8199(__int64 a1, unsigned __int8 a2, unsigned __int8 a3, mystruct_1 *a4)\n{\n  bool v4; // al\n  bool v5; // al\n  int *v6; // rax\n  __int64 *v7; // r12\n  char *v8; // rbx\n  int *v9; // rax\n  bool v11; // [rsp+2Eh] [rbp-12h]\n  bool v12; // [rsp+2Fh] [rbp-11h]\n\n  v4 = a4->mem1_35 != 1 || a4->mem1_38;\n  v11 = v4;\n  v5 = !v4 && a4->mem1_41 != 1;\n  v12 = v5;\n  if ( (unsigned __int8)sub_6B1F(a1, a3, a2) == 1 )\n    return 1LL;\n  if ( v11 || v12 && (v6 = __errno_location(), !sub_793C(*v6)) )\n  {\n    v7 = sub_13B16(0, 4u, a1);\n    v8 = gettext(\"failed to set the security context of %s\");\n    v9 = __errno_location();\n    error(0, *v9, v8, v7);\n  }\n  return 0LL;\n}\n",
  "0x82f1": "_BOOL8 __fastcall sub_82F1(mystruct_1 *a1)\n{\n  return (*(_DWORD *)&a1->mem1_24 & 0xF000) == 0x8000 && *(_QWORD *)&a1->mem1_64 < *(_QWORD *)&a1->mem1_48 / 512LL;\n}\n",
  "0x8348": "__int64 __fastcall sub_8348(\n        const char *a1,\n        const char *a2,\n        mystruct_1 *a3,\n        unsigned int a4,\n        int a5,\n        char *a6,\n        mystruct_2 *a7)\n{\n  void *v7; // rdx\n  __int64 *v8; // r12\n  char *v9; // rbx\n  int *v10; // rax\n  __int64 *v12; // r12\n  char *v13; // rbx\n  int *v14; // rax\n  __int64 *v15; // rbx\n  char *v16; // rax\n  int v17; // eax\n  __int64 *v18; // r12\n  char *v19; // rbx\n  int *v20; // rax\n  __int64 *v21; // rbx\n  char *v22; // rax\n  __int64 *v23; // rbx\n  char *v24; // rax\n  __int64 *v25; // rbx\n  char *v26; // rax\n  __int64 v27; // rsi\n  __int64 v28; // rdi\n  __int64 *v29; // r12\n  char *v30; // rbx\n  int *v31; // rax\n  int v32; // eax\n  __int64 *v33; // r13\n  __int64 *v34; // r12\n  char *v35; // rbx\n  int *v36; // rax\n  __int64 v37; // rdx\n  __int64 v38; // rcx\n  __int64 v39; // r8\n  __int64 v40; // r9\n  __blksize_t st_blksize; // rax\n  __int64 v42; // rsi\n  __int64 v43; // rdx\n  __int64 v44; // rcx\n  __int64 v45; // r8\n  __int64 v46; // r9\n  void *v47; // rax\n  int v48; // edi\n  unsigned __int64 v49; // r8\n  __int64 *v50; // r12\n  char *v51; // rbx\n  int *v52; // rax\n  __int64 v53; // rdx\n  __int64 v54; // rdx\n  __int64 *v55; // r12\n  char *v56; // rbx\n  int *v57; // rax\n  int v58; // eax\n  __int16 v59; // ax\n  __int64 *v60; // r12\n  char *v61; // rbx\n  int *v62; // rax\n  __int64 *v63; // r12\n  char *v64; // rbx\n  int *v65; // rax\n  __int64 *v66; // r12\n  char *v67; // rbx\n  int *v68; // rax\n  char v75[11]; // [rsp+39h] [rbp-1D7h] BYREF\n  int errnum; // [rsp+44h] [rbp-1CCh]\n  unsigned int v77; // [rsp+48h] [rbp-1C8h]\n  int fd; // [rsp+4Ch] [rbp-1C4h]\n  int v79; // [rsp+50h] [rbp-1C0h]\n  int v80; // [rsp+54h] [rbp-1BCh]\n  __off_t length; // [rsp+58h] [rbp-1B8h] BYREF\n  void *ptr; // [rsp+60h] [rbp-1B0h]\n  int v83[2]; // [rsp+68h] [rbp-1A8h]\n  void *v84; // [rsp+70h] [rbp-1A0h]\n  unsigned __int64 v85; // [rsp+78h] [rbp-198h]\n  unsigned __int64 v86; // [rsp+80h] [rbp-190h]\n  unsigned __int64 v87; // [rsp+88h] [rbp-188h]\n  unsigned __int64 v88; // [rsp+90h] [rbp-180h]\n  int v89[2]; // [rsp+98h] [rbp-178h]\n  __int64 v90[4]; // [rsp+A0h] [rbp-170h] BYREF\n  struct stat v91; // [rsp+C0h] [rbp-150h] BYREF\n  struct stat v92; // [rsp+150h] [rbp-C0h] BYREF\n  unsigned __int64 v93; // [rsp+1E8h] [rbp-28h]\n\n  v93 = __readfsqword(0x28u);\n  ptr = 0LL;\n  v84 = 0LL;\n  v77 = *(_DWORD *)&a7->mem2_24;\n  v75[1] = 1;\n  v75[2] = a3->mem1_35;\n  if ( *(_DWORD *)&a3->mem1_4 == 2 )\n    v7 = &unk_20000;\n  else\n    LODWORD(v7) = 0;\n  fd = sub_FB53(a1, (char)v7, (unsigned int)v7);\n  if ( fd < 0 )\n  {\n    v8 = sub_13BE4(4u, (__int64)a1);\n    v9 = gettext(\"cannot open %s for reading\");\n    v10 = __errno_location();\n    error(0, *v10, v9, v8);\n    return 0LL;\n  }\n  if ( !fstat(fd, &v91) )\n  {\n    if ( *(_QWORD *)&a7->mem2_8 != v91.st_ino || *(_QWORD *)&a7->mem2_0 != v91.st_dev )\n    {\n      v15 = sub_13BE4(4u, (__int64)a1);\n      v16 = gettext(\"skipping file %s, as it was replaced while being copied\");\n      error(0, 0, v16, v15);\n      v75[1] = 0;\n      goto LABEL_131;\n    }\n    if ( *a6 != 1 )\n    {\n      if ( a3->mem1_35 )\n        v17 = 513;\n      else\n        v17 = 1;\n      v79 = v17;\n      *(_DWORD *)&v75[7] = sub_FB53(a2, v17, v17);\n      errnum = *__errno_location();\n      if ( (a3->mem1_33 || a3->mem1_37)\n        && *(int *)&v75[7] >= 0\n        && (unsigned __int8)sub_8199((__int64)a2, a3->mem1_37, 0, a3) != 1\n        && a3->mem1_38 )\n      {\n        v75[1] = 0;\n        goto LABEL_129;\n      }\n      if ( *(int *)&v75[7] < 0 && a3->mem1_22 )\n      {\n        if ( unlink(a2) )\n        {\n          v18 = sub_13BE4(4u, (__int64)a2);\n          v19 = gettext(\"cannot remove %s\");\n          v20 = __errno_location();\n          error(0, *v20, v19, v18);\n          v75[1] = 0;\n          goto LABEL_131;\n        }\n        if ( a3->mem1_46 )\n        {\n          v21 = sub_13BE4(4u, (__int64)a2);\n          v22 = gettext(\"removed %s\\n\");\n          printf(v22, v21);\n        }\n        *a6 = 1;\n        if ( a3->mem1_33 && (unsigned __int8)sub_7F19((__int64)a1, (__int64)a2, a4, *a6, a3) != 1 )\n        {\n          v75[1] = 0;\n          goto LABEL_131;\n        }\n      }\n    }\n    if ( !*a6 )\n    {\n      a5 = 0;\n      goto LABEL_45;\n    }\n    while ( 1 )\n    {\n      v80 = 65;\n      *(_DWORD *)&v75[7] = sub_FB53(a2, 193, a4 & ~a5);\n      errnum = *__errno_location();\n      if ( *(int *)&v75[7] < 0\n        && errnum == 17\n        && a3->mem1_24 != 1\n        && !lstat(a2, &v92)\n        && (v92.st_mode & 0xF000) == 40960 )\n      {\n        if ( !a3->mem1_48 )\n        {\n          v23 = sub_13BE4(4u, (__int64)a2);\n          v24 = gettext(\"not writing through dangling symlink %s\");\n          error(0, 0, v24, v23);\n          v75[1] = 0;\n          goto LABEL_131;\n        }\n        *(_DWORD *)&v75[7] = sub_FB53(a2, v80, a4 & ~a5);\n        errnum = *__errno_location();\n      }\n      if ( *(int *)&v75[7] < 0 && errnum == 21 && *a2 && a2[strlen(a2) - 1] == 47 )\n        errnum = 20;\nLABEL_45:\n      if ( *(int *)&v75[7] >= 0 )\n        break;\n      if ( errnum != 2 || *a6 == 1 || a3->mem1_24 == 1 )\n      {\n        v25 = sub_13BE4(4u, (__int64)a2);\n        v26 = gettext(\"cannot create regular file %s\");\n        error(0, errnum, v26, v25);\n        v75[1] = 0;\n        goto LABEL_131;\n      }\n      *a6 = 1;\n    }\n    v27 = (__int64)&v92;\n    v28 = *(unsigned int *)&v75[7];\n    if ( fstat(*(int *)&v75[7], &v92) )\n    {\n      v29 = sub_13BE4(4u, (__int64)a2);\n      v30 = gettext(\"cannot fstat %s\");\n      v31 = __errno_location();\n      error(0, *v31, v30, v29);\n      v75[1] = 0;\n      goto LABEL_129;\n    }\n    if ( v75[2] )\n    {\n      if ( *(_DWORD *)&a3->mem1_56 )\n      {\n        v27 = (unsigned int)fd;\n        v28 = *(unsigned int *)&v75[7];\n        v32 = sub_71BA(*(int *)&v75[7], fd);\n        v75[5] = v32 == 0;\n        if ( !v32 || *(_DWORD *)&a3->mem1_56 == 2 )\n        {\n          if ( v75[5] != 1 )\n          {\n            v33 = sub_13B16(1u, 4u, (__int64)a1);\n            v34 = sub_13B16(0, 4u, (__int64)a2);\n            v35 = gettext(\"failed to clone %s from %s\");\n            v36 = __errno_location();\n            error(0, *v36, v35, v34, v33);\n            v75[1] = 0;\n            goto LABEL_129;\n          }\n          v75[2] = 0;\n        }\n      }\n    }\n    if ( v75[2] )\n    {\n      v85 = getpagesize();\n      *(_QWORD *)v83 = sub_6A99(\n                         v28,\n                         v27,\n                         v37,\n                         v38,\n                         v39,\n                         v40,\n                         v92.st_dev,\n                         v92.st_ino,\n                         v92.st_nlink,\n                         v92.st_mode,\n                         v92.st_gid,\n                         v92.st_rdev,\n                         v92.st_size,\n                         v92.st_blksize);\n      if ( v92.st_blksize <= 0 || v92.st_blksize > 0x2000000000000000uLL )\n        st_blksize = 512LL;\n      else\n        st_blksize = v92.st_blksize;\n      v86 = st_blksize;\n      v42 = 0LL;\n      sub_FADF(fd, 0LL, 0LL, 2);\n      v75[3] = 0;\n      v75[6] = sub_82F1((mystruct_1 *)&v91);\n      if ( (v92.st_mode & 0xF000) == 0x8000 )\n      {\n        v75[3] = *(_DWORD *)&a3->mem1_12 == 3;\n        if ( *(_DWORD *)&a3->mem1_12 == 2 )\n        {\n          if ( v75[6] )\n            v75[3] = 1;\n        }\n      }\n      if ( v75[3] != 1 )\n      {\n        v87 = 0x7FFFFFFFFFFFFFFFLL - v85;\n        v47 = sub_6A99(\n                (__int64)&v91,\n                0LL,\n                v43,\n                v44,\n                v45,\n                v46,\n                v91.st_dev,\n                v91.st_ino,\n                v91.st_nlink,\n                v91.st_mode,\n                v91.st_gid,\n                v91.st_rdev,\n                v91.st_size,\n                v91.st_blksize);\n        v42 = *(_QWORD *)v83;\n        v88 = sub_F534((unsigned __int64)v47, *(unsigned __int64 *)v83, 0x7FFFFFFFFFFFFFFFLL - v85);\n        if ( (v91.st_mode & 0xF000) == 0x8000 && *(_QWORD *)v83 > v91.st_size )\n          *(_QWORD *)v83 = v91.st_size + 1;\n        *(_QWORD *)v83 = v88 + *(_QWORD *)v83 - 1 - (v88 + *(_QWORD *)v83 - 1) % v88;\n        if ( !*(_QWORD *)v83 || v87 < *(_QWORD *)v83 )\n          *(_QWORD *)v83 = v88;\n      }\n      ptr = sub_1745E(*(_QWORD *)v83 + v85, v42);\n      *(_QWORD *)v89 = sub_6964((__int64)ptr, v85);\n      if ( v75[6] )\n      {\n        if ( v75[3] )\n          v48 = *(_DWORD *)&a3->mem1_12;\n        else\n          v48 = 1;\n        if ( (unsigned __int8)sub_729B(\n                                fd,\n                                *(unsigned int *)&v75[7],\n                                *(void **)v89,\n                                *(size_t *)v83,\n                                v86,\n                                v91.st_size,\n                                v48,\n                                (__int64)a1,\n                                (__int64)a2,\n                                &length) )\n          goto LABEL_91;\n        if ( (unsigned __int8)length != 1 )\n        {\n          v75[1] = 0;\n          goto LABEL_129;\n        }\n      }\n      if ( v75[3] )\n        v49 = v86;\n      else\n        v49 = 0LL;\n      if ( !sub_6D9B(\n              fd,\n              *(unsigned int *)&v75[7],\n              *(void **)v89,\n              *(size_t *)v83,\n              v49,\n              *(_DWORD *)&a3->mem1_12 == 3,\n              (__int64)a1,\n              (__int64)a2,\n              0xFFFFFFFFFFFFFFFFLL,\n              &length,\n              v75) )\n      {\n        v75[1] = 0;\n        goto LABEL_129;\n      }\n      if ( v75[0] && ftruncate(*(int *)&v75[7], length) < 0 )\n      {\n        v50 = sub_13BE4(4u, (__int64)a2);\n        v51 = gettext(\"failed to extend %s\");\n        v52 = __errno_location();\n        error(0, *v52, v51, v50);\n        v75[1] = 0;\n        goto LABEL_129;\n      }\n    }\nLABEL_91:\n    if ( a3->mem1_31 )\n    {\n      v90[0] = sub_14E7E((__int64)a7);\n      v90[1] = v53;\n      v90[2] = sub_14EB2((__int64)a7);\n      v90[3] = v54;\n      if ( sub_16021(*(int *)&v75[7], a2, v90) )\n      {\n        v55 = sub_13BE4(4u, (__int64)a2);\n        v56 = gettext(\"preserving times for %s\");\n        v57 = __errno_location();\n        error(0, *v57, v56, v55);\n        if ( a3->mem1_36 )\n        {\n          v75[1] = 0;\n          goto LABEL_129;\n        }\n      }\n    }\n    if ( a3->mem1_29 && (*(_DWORD *)&a7->mem2_28 != v92.st_uid || *(_DWORD *)&a7->mem2_32 != v92.st_gid) )\n    {\n      v58 = sub_7C6A((mystruct_2 *)a3, a2, *(unsigned int *)&v75[7], (mystruct_1 *)a7, *a6, (mystruct_3 *)&v92);\n      if ( v58 == -1 )\n      {\n        v75[1] = 0;\nLABEL_129:\n        if ( close(*(int *)&v75[7]) < 0 )\n        {\n          v63 = sub_13BE4(4u, (__int64)a2);\n          v64 = gettext(\"failed to close %s\");\n          v65 = __errno_location();\n          error(0, *v65, v64, v63);\n          v75[1] = 0;\n        }\n        goto LABEL_131;\n      }\n      if ( !v58 )\n        v77 &= 0xFFFFF1FF;\n    }\n    if ( a3->mem1_39 )\n    {\n      v75[4] = 0;\n      if ( (v92.st_mode & 0x80) == 0 && geteuid() )\n        v75[4] = sub_82B1(*(int *)&v75[7], a2, 0x180u) == 0;\n      if ( (unsigned __int8)sub_7964(a1, (unsigned int)fd, a2, *(unsigned int *)&v75[7], a3) != 1 && a3->mem1_40 )\n        v75[1] = 0;\n      if ( v75[4] )\n        sub_82B1(*(int *)&v75[7], a2, a4 & ~a5);\n    }\n    sub_7F03();\n    if ( a3->mem1_30 || a3->mem1_24 )\n    {\n      if ( (unsigned int)sub_E265((__int64)a1, fd, (__int64)a2, *(unsigned int *)&v75[7], v77) && a3->mem1_36 )\n        v75[1] = 0;\n    }\n    else if ( a3->mem1_43 )\n    {\n      if ( (unsigned int)sub_E332((__int64)a2, *(unsigned int *)&v75[7], *(_DWORD *)&a3->mem1_16) )\n        v75[1] = 0;\n    }\n    else if ( a3->mem1_32 && *a6 )\n    {\n      v59 = sub_D2C6();\n      if ( (unsigned int)sub_E332((__int64)a2, *(unsigned int *)&v75[7], ~v59 & 0x1B6) )\n        v75[1] = 0;\n    }\n    else if ( a5 )\n    {\n      if ( (~(unsigned int)sub_D2C6() & a5) != 0 )\n      {\n        if ( sub_82B1(*(int *)&v75[7], a2, a4) )\n        {\n          v60 = sub_13BE4(4u, (__int64)a2);\n          v61 = gettext(\"preserving permissions for %s\");\n          v62 = __errno_location();\n          error(0, *v62, v61, v60);\n          if ( a3->mem1_36 )\n            v75[1] = 0;\n        }\n      }\n    }\n    goto LABEL_129;\n  }\n  v12 = sub_13BE4(4u, (__int64)a1);\n  v13 = gettext(\"cannot fstat %s\");\n  v14 = __errno_location();\n  error(0, *v14, v13, v12);\n  v75[1] = 0;\nLABEL_131:\n  if ( close(fd) < 0 )\n  {\n    v66 = sub_13BE4(4u, (__int64)a1);\n    v67 = gettext(\"failed to close %s\");\n    v68 = __errno_location();\n    error(0, *v68, v67, v66);\n    v75[1] = 0;\n  }\n  free(ptr);\n  free(v84);\n  return (unsigned __int8)v75[1];\n}\n",
  "0x947b": "_BOOL8 __fastcall sub_947B(const char *a1, struct stat *a2, const char *a3, struct stat *a4, mystruct_1 *a5, bool *a6)\n{\n  bool v6; // al\n  bool v8; // al\n  __ino_t st_ino; // rbx\n  __int64 v10; // rbx\n  __dev_t st_rdev; // rbx\n  __blksize_t st_blksize; // rbx\n  __time_t tv_sec; // rbx\n  __time_t v14; // rbx\n  __time_t v15; // rbx\n  __syscall_slong_t v16; // rbx\n  __syscall_slong_t v17; // rdx\n  __ino_t v18; // rbx\n  __int64 v19; // rbx\n  __dev_t v20; // rbx\n  __blksize_t v21; // rbx\n  __time_t v22; // rbx\n  __time_t v23; // rbx\n  __time_t v24; // rbx\n  __syscall_slong_t v25; // rbx\n  __syscall_slong_t v26; // rdx\n  bool v30; // [rsp+34h] [rbp-15Ch]\n  bool v31; // [rsp+35h] [rbp-15Bh]\n  char v32; // [rsp+36h] [rbp-15Ah]\n  bool v33; // [rsp+37h] [rbp-159h]\n  struct stat *v34; // [rsp+38h] [rbp-158h]\n  struct stat *v35; // [rsp+40h] [rbp-150h]\n  char *ptr; // [rsp+48h] [rbp-148h]\n  struct stat v37; // [rsp+50h] [rbp-140h] BYREF\n  struct stat v38; // [rsp+E0h] [rbp-B0h] BYREF\n  unsigned __int64 v39; // [rsp+178h] [rbp-18h]\n\n  v39 = __readfsqword(0x28u);\n  v6 = *(_OWORD *)&a2->st_dev == *(_OWORD *)&a4->st_dev;\n  v31 = v6;\n  *a6 = 0;\n  if ( v6 && a5->mem1_23 )\n  {\n    *a6 = 1;\n    return 1LL;\n  }\n  if ( *(_DWORD *)&a5->mem1_4 == 2 )\n  {\n    v30 = v6;\n    if ( (a2->st_mode & 0xF000) == 40960 && (a4->st_mode & 0xF000) == 40960 )\n    {\n      v32 = sub_144BD((__int64)a1, (__int64)a3);\n      if ( v32 == 1 )\n        return v32 == 0;\n      if ( *(_DWORD *)&a5->mem1_0 )\n        return 1LL;\n      if ( !v31 )\n        return v32 == 0;\n      *a6 = 1;\n      return a5->mem1_24 == 0;\n    }\n    v34 = a2;\n    v35 = a4;\n  }\n  else\n  {\n    if ( !v6 )\n      return 1LL;\n    if ( lstat(a3, &v37) || lstat(a1, &v38) )\n      return 1LL;\n    v34 = &v38;\n    v35 = &v37;\n    v8 = v38.st_ino == v37.st_ino && v38.st_dev == v37.st_dev;\n    v30 = v8;\n    if ( (v38.st_mode & 0xF000) == 40960 && (v37.st_mode & 0xF000) == 40960 && a5->mem1_21 )\n      return 1LL;\n  }\n  if ( *(_DWORD *)&a5->mem1_0 )\n  {\n    if ( !v30 )\n      return a5->mem1_24 == 1\n          || *(_DWORD *)&a5->mem1_4 == 2\n          || (v34->st_mode & 0xF000) != 40960\n          || (v35->st_mode & 0xF000) == 40960;\n    else\n      return (unsigned __int8)sub_144BD((__int64)a1, (__int64)a3) == 0;\n  }\n  else\n  {\n    if ( a5->mem1_24 || a5->mem1_21 )\n    {\n      if ( (v35->st_mode & 0xF000) == 40960 )\n        return 1LL;\n      if ( v30 && v35->st_nlink > 1 && (unsigned __int8)sub_144BD((__int64)a1, (__int64)a3) != 1 )\n        return a5->mem1_24 == 0;\n    }\n    if ( (v34->st_mode & 0xF000) != 40960 && (v35->st_mode & 0xF000) != 40960 )\n    {\n      if ( v34->st_ino != v35->st_ino || v34->st_dev != v35->st_dev )\n        return 1LL;\n      if ( a5->mem1_23 )\n      {\n        *a6 = 1;\n        return 1LL;\n      }\n    }\n    if ( a5->mem1_24 )\n    {\n      if ( (a2->st_mode & 0xF000) == 40960 && v35->st_nlink > 1 )\n      {\n        ptr = canonicalize_file_name(a1);\n        if ( ptr )\n        {\n          v33 = (unsigned __int8)sub_144BD((__int64)ptr, (__int64)a3) == 0;\n          free(ptr);\n          return v33;\n        }\n      }\n    }\n    if ( a5->mem1_44 && (v35->st_mode & 0xF000) == 40960 )\n      return 1LL;\n    if ( *(_DWORD *)&a5->mem1_4 != 2 )\n      return 0LL;\n    if ( (v34->st_mode & 0xF000) == 40960 )\n    {\n      if ( stat(a1, &v38) )\n        return 1LL;\n    }\n    else\n    {\n      st_ino = v34->st_ino;\n      v38.st_dev = v34->st_dev;\n      v38.st_ino = st_ino;\n      v10 = *(_QWORD *)&v34->st_mode;\n      v38.st_nlink = v34->st_nlink;\n      *(_QWORD *)&v38.st_mode = v10;\n      st_rdev = v34->st_rdev;\n      *(_QWORD *)&v38.st_gid = *(_QWORD *)&v34->st_gid;\n      v38.st_rdev = st_rdev;\n      st_blksize = v34->st_blksize;\n      v38.st_size = v34->st_size;\n      v38.st_blksize = st_blksize;\n      tv_sec = v34->st_atim.tv_sec;\n      v38.st_blocks = v34->st_blocks;\n      v38.st_atim.tv_sec = tv_sec;\n      v14 = v34->st_mtim.tv_sec;\n      v38.st_atim.tv_nsec = v34->st_atim.tv_nsec;\n      v38.st_mtim.tv_sec = v14;\n      v15 = v34->st_ctim.tv_sec;\n      v38.st_mtim.tv_nsec = v34->st_mtim.tv_nsec;\n      v38.st_ctim.tv_sec = v15;\n      v16 = v34->__unused[0];\n      v38.st_ctim.tv_nsec = v34->st_ctim.tv_nsec;\n      v38.__unused[0] = v16;\n      v17 = v34->__unused[2];\n      v38.__unused[1] = v34->__unused[1];\n      v38.__unused[2] = v17;\n    }\n    if ( (v35->st_mode & 0xF000) == 40960 )\n    {\n      if ( stat(a3, &v37) )\n        return 1LL;\n    }\n    else\n    {\n      v18 = v35->st_ino;\n      v37.st_dev = v35->st_dev;\n      v37.st_ino = v18;\n      v19 = *(_QWORD *)&v35->st_mode;\n      v37.st_nlink = v35->st_nlink;\n      *(_QWORD *)&v37.st_mode = v19;\n      v20 = v35->st_rdev;\n      *(_QWORD *)&v37.st_gid = *(_QWORD *)&v35->st_gid;\n      v37.st_rdev = v20;\n      v21 = v35->st_blksize;\n      v37.st_size = v35->st_size;\n      v37.st_blksize = v21;\n      v22 = v35->st_atim.tv_sec;\n      v37.st_blocks = v35->st_blocks;\n      v37.st_atim.tv_sec = v22;\n      v23 = v35->st_mtim.tv_sec;\n      v37.st_atim.tv_nsec = v35->st_atim.tv_nsec;\n      v37.st_mtim.tv_sec = v23;\n      v24 = v35->st_ctim.tv_sec;\n      v37.st_mtim.tv_nsec = v35->st_mtim.tv_nsec;\n      v37.st_ctim.tv_sec = v24;\n      v25 = v35->__unused[0];\n      v37.st_ctim.tv_nsec = v35->st_ctim.tv_nsec;\n      v37.__unused[0] = v25;\n      v26 = v35->__unused[2];\n      v37.__unused[1] = v35->__unused[1];\n      v37.__unused[2] = v26;\n    }\n    if ( v38.st_ino != v37.st_ino || v38.st_dev != v37.st_dev )\n      return 1LL;\n    if ( a5->mem1_23 )\n    {\n      *a6 = (v35->st_mode & 0xF000) != 40960;\n      return 1LL;\n    }\n    else\n    {\n      return 0LL;\n    }\n  }\n}\n",
  "0x9cf2": "_BOOL8 __fastcall sub_9CF2(mystruct_2 *a1, const char *a2, mystruct_1 *a3)\n{\n  __int64 v3; // r13\n  __int64 *v4; // r12\n  __int64 v5; // rbx\n  char *v6; // rax\n  __int64 *v7; // r12\n  __int64 v8; // rbx\n  char *v9; // rax\n  char v12; // [rsp+2Ch] [rbp-34h] BYREF\n  _BYTE v13[11]; // [rsp+2Dh] [rbp-33h] BYREF\n  unsigned __int64 v14; // [rsp+38h] [rbp-28h]\n\n  v14 = __readfsqword(0x28u);\n  if ( !sub_9CA1(a2, *(_DWORD *)&a3->mem1_24) )\n  {\n    sub_FE61(*(_DWORD *)&a3->mem1_24, &v12);\n    v13[9] = 0;\n    v3 = *(_DWORD *)&a3->mem1_24 & 0xFFF;\n    v4 = sub_13BE4(4u, (__int64)a2);\n    v5 = qword_24608;\n    if ( a1->mem2_24 || a1->mem2_21 || a1->mem2_22 )\n      v6 = gettext(\"%s: replace %s, overriding mode %04lo (%s)? \");\n    else\n      v6 = gettext(\"%s: unwritable %s (mode %04lo, %s); try anyway? \");\n    fprintf(stderr, v6, v5, v4, v3, v13);\n  }\n  else\n  {\n    v7 = sub_13BE4(4u, (__int64)a2);\n    v8 = qword_24608;\n    v9 = gettext(\"%s: overwrite %s? \");\n    fprintf(stderr, v9, v8, v7);\n  }\n  return sub_1765B();\n}\n",
  "0x9e5c": "size_t *__fastcall sub_9E5C(mystruct_1 *a1)\n{\n  size_t *result; // rax\n\n  result = sub_10C1E(\n             61LL,\n             0LL,\n             (unsigned __int64 (__fastcall *)(__int64, unsigned __int64))sub_11CD5,\n             (bool (__fastcall *)(__int64, __int64))sub_11D53,\n             (size_t)sub_11E4B);\n  *(_QWORD *)&a1->mem1_64 = result;\n  return result;\n}\n",
  "0x9ea4": "size_t *__fastcall sub_9EA4(mystruct_1 *a1)\n{\n  size_t *result; // rax\n\n  result = sub_10C1E(61LL, 0LL, sub_11D25, (bool (__fastcall *)(__int64, __int64))sub_11D53, (size_t)sub_11E4B);\n  *(_QWORD *)&a1->mem1_72 = result;\n  return result;\n}\n",
  "0x9eec": "_BOOL8 __fastcall sub_9EEC(mystruct_1 *a1, const char *a2, __int64 a3)\n{\n  if ( !a1->mem1_24 )\n    __assert_fail(\"x->move_mode\", \"../src/copy.c\", 0x6F4u, \"abandon_move\");\n  return *(_DWORD *)&a1->mem1_8 == 2\n      || (*(_DWORD *)&a1->mem1_8 == 3\n       || *(_DWORD *)&a1->mem1_8 == 4 && a1->mem1_47 && !sub_9CA1(a2, *(_DWORD *)(a3 + 24)))\n      && !sub_9CF2((mystruct_2 *)a1, a2, (mystruct_1 *)a3);\n}\n",
  "0xa1d4": "_BOOL8 __fastcall sub_A1D4(mystruct_1 *a1, char a2)\n{\n  return *(_DWORD *)&a1->mem1_4 == 4 || *(_DWORD *)&a1->mem1_4 == 3 && a2;\n}\n",
  "0xa210": "_BOOL8 __fastcall sub_A210(const char *a1, mystruct_1 *a2, char *a3)\n{\n  char *v3; // rsi\n  const char *v5; // rbx\n  char *v6; // rax\n  int v10; // [rsp+2Ch] [rbp-E4h]\n  size_t v11; // [rsp+30h] [rbp-E0h]\n  char *v12; // [rsp+38h] [rbp-D8h]\n  size_t n; // [rsp+40h] [rbp-D0h]\n  size_t v14; // [rsp+48h] [rbp-C8h]\n  size_t v15; // [rsp+50h] [rbp-C0h]\n  void *dest; // [rsp+58h] [rbp-B8h]\n  struct stat v17; // [rsp+60h] [rbp-B0h] BYREF\n  unsigned __int64 v18; // [rsp+F8h] [rbp-18h]\n\n  v18 = __readfsqword(0x28u);\n  v11 = strlen(a1);\n  v12 = sub_F9B9(a3);\n  n = strlen(v12);\n  v14 = strlen(src);\n  if ( v11 != n + v14 )\n    return 0LL;\n  if ( memcmp(a1, v12, n) )\n    return 0LL;\n  v3 = src;\n  if ( strcmp(&a1[n], src) )\n    return 0LL;\n  v15 = strlen(a3);\n  dest = sub_1745E(v15 + v14 + 1, (__int64)v3);\n  v5 = src;\n  v6 = (char *)mempcpy(dest, a3, v15);\n  strcpy(v6, v5);\n  v10 = stat((const char *)dest, &v17);\n  free(dest);\n  return !v10 && *(_QWORD *)&a2->mem1_8 == v17.st_ino && *(_QWORD *)&a2->mem1_0 == v17.st_dev;\n}\n",
  "0xa404": "_BOOL8 __fastcall sub_A404(\n        char *a1,\n        char *a2,\n        char a3,\n        _QWORD *a4,\n        mystruct_2 *a5,\n        mystruct_1 *a6,\n        char a7,\n        bool *a8,\n        bool *a9,\n        _BYTE *a10)\n{\n  int v10; // eax\n  char v11; // al\n  char *v12; // rax\n  int v13; // eax\n  __int64 *v14; // r12\n  char *v15; // rbx\n  int *v16; // rax\n  __int64 *v18; // rbx\n  char *v19; // rax\n  __int64 *v20; // rbx\n  char *v21; // rax\n  bool v22; // al\n  int v23; // eax\n  __int64 *v24; // r12\n  char *v25; // rbx\n  int *v26; // rax\n  __int64 *v27; // r12\n  __int64 *v28; // rbx\n  char *v29; // rax\n  _BOOL4 v30; // eax\n  __int64 *v31; // r12\n  __int64 *v32; // rbx\n  char *v33; // rax\n  __int64 *v34; // r12\n  __int64 *v35; // rbx\n  char *v36; // rax\n  __int64 *v37; // rbx\n  char *v38; // rax\n  __int64 *v39; // r12\n  __int64 *v40; // rbx\n  char *v41; // rax\n  char *v42; // rax\n  __int64 *v43; // rbx\n  __int64 *v44; // rax\n  size_t v45; // rax\n  unsigned __int64 v46; // rax\n  void *v47; // rsp\n  __int64 *v48; // r12\n  char *v49; // rbx\n  int *v50; // rax\n  __int64 *v51; // r12\n  char *v52; // rbx\n  int *v53; // rax\n  __int64 *v54; // rbx\n  char *v55; // rax\n  __int64 *v56; // r12\n  __int64 *v57; // rbx\n  char *v58; // rax\n  __int64 *v59; // r12\n  __int64 *v60; // rbx\n  char *v61; // rax\n  __int64 *v62; // rbx\n  char *v63; // rax\n  __int64 *v64; // r12\n  __int64 *v65; // rbx\n  char *v66; // rax\n  int v67; // eax\n  char *v68; // rax\n  __int64 *v69; // r12\n  __int64 *v70; // rbx\n  char *v71; // rax\n  __int64 *v72; // r12\n  __int64 *v73; // rbx\n  char *v74; // rax\n  bool v75; // al\n  __int64 *v76; // r13\n  __int64 *v77; // r12\n  char *v78; // rbx\n  int *v79; // rax\n  char *v80; // rax\n  int v81; // eax\n  int v82; // eax\n  char *v83; // rsi\n  __int64 *v84; // rbx\n  char *v85; // rax\n  void *v86; // rsp\n  __int64 *v87; // r12\n  char *v88; // rbx\n  int *v89; // rax\n  __int64 *v90; // r12\n  char *v91; // rbx\n  int *v92; // rax\n  __int64 *v93; // r12\n  char *v94; // rbx\n  int *v95; // rax\n  __int64 *v96; // rbx\n  char *v97; // rax\n  bool v98; // al\n  __int64 *v99; // rbx\n  char *v100; // rax\n  __int64 *v101; // r12\n  __int64 *v102; // rbx\n  char *v103; // rax\n  bool v104; // al\n  unsigned int v105; // eax\n  __int64 *v106; // r12\n  char *v107; // rbx\n  int *v108; // rax\n  __int64 *v109; // r12\n  char *v110; // rbx\n  int *v111; // rax\n  __int64 *v112; // r12\n  char *v113; // rbx\n  int *v114; // rax\n  __off_t st_size; // rbx\n  __int64 *v116; // rbx\n  char *v117; // rax\n  char *v118; // rbx\n  int *v119; // rax\n  __int64 *v120; // rbx\n  char *v121; // rax\n  __ino_t v122; // rdx\n  __int64 v123; // rdx\n  __int64 *v125; // r12\n  char *v126; // rbx\n  int *v127; // rax\n  int v128; // eax\n  int v129; // eax\n  int v130; // eax\n  __int64 *v131; // r12\n  char *v132; // rbx\n  int *v133; // rax\n  __int64 *v134; // r12\n  char *v135; // rbx\n  int *v136; // rax\n  __int64 *v137; // r12\n  char *v138; // rbx\n  int *v139; // rax\n  __int64 *v140; // r12\n  __int64 *v141; // rbx\n  char *v142; // rax\n  mystruct_2 *v143; // [rsp+8h] [rbp-370h] BYREF\n  _BYTE *st_ino; // [rsp+10h] [rbp-368h]\n  bool *st_dev; // [rsp+18h] [rbp-360h]\n  bool *v146; // [rsp+20h] [rbp-358h]\n  mystruct_1 *v147; // [rsp+28h] [rbp-350h]\n  mystruct_2 *v148; // [rsp+30h] [rbp-348h]\n  _QWORD *v149; // [rsp+38h] [rbp-340h]\n  char v150; // [rsp+40h] [rbp-338h]\n  char v151[4]; // [rsp+44h] [rbp-334h] BYREF\n  char *name; // [rsp+48h] [rbp-330h]\n  char *old; // [rsp+50h] [rbp-328h]\n  bool v154; // [rsp+61h] [rbp-317h] BYREF\n  char v155; // [rsp+62h] [rbp-316h]\n  bool v156; // [rsp+63h] [rbp-315h]\n  char v157; // [rsp+64h] [rbp-314h]\n  char v158; // [rsp+65h] [rbp-313h]\n  bool v159; // [rsp+66h] [rbp-312h]\n  char v160; // [rsp+67h] [rbp-311h]\n  bool v161; // [rsp+68h] [rbp-310h]\n  bool v162; // [rsp+69h] [rbp-30Fh]\n  bool v163; // [rsp+6Ah] [rbp-30Eh]\n  bool v164; // [rsp+6Bh] [rbp-30Dh]\n  unsigned int st_mode; // [rsp+6Ch] [rbp-30Ch]\n  __mode_t v166; // [rsp+70h] [rbp-308h]\n  int v167; // [rsp+74h] [rbp-304h]\n  int errnum; // [rsp+78h] [rbp-300h]\n  int v169; // [rsp+7Ch] [rbp-2FCh]\n  int v170; // [rsp+80h] [rbp-2F8h]\n  int v171; // [rsp+84h] [rbp-2F4h]\n  _BOOL4 v172; // [rsp+88h] [rbp-2F0h]\n  int v173; // [rsp+8Ch] [rbp-2ECh]\n  int v174; // [rsp+90h] [rbp-2E8h]\n  int v175; // [rsp+94h] [rbp-2E4h]\n  __int64 v176; // [rsp+98h] [rbp-2E0h]\n  char *v177; // [rsp+A0h] [rbp-2D8h]\n  struct stat *v178; // [rsp+A8h] [rbp-2D0h]\n  char *v179; // [rsp+B0h] [rbp-2C8h]\n  mystruct_1 *v180; // [rsp+B8h] [rbp-2C0h]\n  char *format; // [rsp+C0h] [rbp-2B8h]\n  void *ptr; // [rsp+C8h] [rbp-2B0h]\n  char *s; // [rsp+D0h] [rbp-2A8h]\n  size_t n; // [rsp+D8h] [rbp-2A0h]\n  void *dest; // [rsp+E0h] [rbp-298h]\n  char *v186; // [rsp+E8h] [rbp-290h]\n  char *s1; // [rsp+F0h] [rbp-288h]\n  char *s2; // [rsp+F8h] [rbp-280h]\n  mystruct_2 **v189; // [rsp+100h] [rbp-278h]\n  struct stat v190; // [rsp+108h] [rbp-270h] BYREF\n  struct stat v191; // [rsp+198h] [rbp-1E0h] BYREF\n  struct stat v192; // [rsp+228h] [rbp-150h] BYREF\n  struct stat v193; // [rsp+2B8h] [rbp-C0h] BYREF\n  unsigned __int64 v194; // [rsp+350h] [rbp-28h]\n\n  old = a1;\n  name = a2;\n  v149 = a4;\n  v148 = a5;\n  v147 = a6;\n  v151[0] = a3;\n  v150 = a7;\n  v146 = a8;\n  st_dev = a9;\n  st_ino = a10;\n  v194 = __readfsqword(0x28u);\n  v155 = 0;\n  v176 = 0LL;\n  v177 = 0LL;\n  v157 = 0;\n  v158 = 0;\n  v159 = 0;\n  *a9 = 0;\n  errnum = *(_DWORD *)&v147->mem1_52;\n  if ( v147->mem1_24 )\n  {\n    if ( errnum < 0 )\n    {\n      if ( sub_1406E(0xFFFFFF9C, old, 0xFFFFFF9C, name, 1) )\n        v10 = *__errno_location();\n      else\n        v10 = 0;\n      errnum = v10;\n    }\n    v151[0] = errnum == 0;\n    if ( st_ino )\n      *st_ino = v151[0];\n  }\n  if ( errnum )\n    v11 = errnum != 17 || *(_DWORD *)&v147->mem1_8 != 2;\n  else\n    v11 = v147->mem1_49 ^ 1;\n  if ( v11 )\n  {\n    if ( errnum )\n      v12 = old;\n    else\n      v12 = name;\n    v179 = v12;\n    if ( *(_DWORD *)&v147->mem1_4 == 2 )\n      v13 = 256;\n    else\n      v13 = 0;\n    v170 = v13;\n    if ( (unsigned int)sub_6B6A(-100, v179, &v190, v13) )\n    {\n      v14 = sub_13BE4(4u, (__int64)v179);\n      v15 = gettext(\"cannot stat %s\");\n      v16 = __errno_location();\n      error(0, *v16, v15, v14);\n      return 0LL;\n    }\n    st_mode = v190.st_mode;\n    if ( (v190.st_mode & 0xF000) == 0x4000 && v147->mem1_42 != 1 )\n    {\n      v18 = sub_13BE4(4u, (__int64)old);\n      if ( v147->mem1_25 != 1 )\n        v19 = gettext(\"-r not specified; omitting directory %s\");\n      else\n        v19 = gettext(\"omitting directory %s\");\n      error(0, 0, v19, v18);\n      return 0LL;\n    }\n  }\n  if ( v150 && *(_QWORD *)&v147->mem1_72 )\n  {\n    if ( (st_mode & 0xF000) != 0x4000\n      && !*(_DWORD *)&v147->mem1_0\n      && sub_FD2F(*(_QWORD *)&v147->mem1_72, (__int64)old, (__int64 *)&v190) )\n    {\n      v20 = sub_13BE4(4u, (__int64)old);\n      v21 = gettext(\"warning: source file %s specified more than once\");\n      error(0, 0, v21, v20);\n      return 1LL;\n    }\n    sub_FC8F(*(_QWORD *)&v147->mem1_72, (__int64)old, &v190);\n  }\n  v161 = sub_A1D4(v147, v150);\n  if ( v151[0] != 1 )\n  {\n    if ( errnum != 17 || *(_DWORD *)&v147->mem1_8 != 2 )\n    {\n      v22 = (st_mode & 0xF000) != 0x8000\n         && (v147->mem1_20 != 1 || (st_mode & 0xF000) == 0x4000 || (st_mode & 0xF000) == 40960)\n         || v147->mem1_24\n         || v147->mem1_44\n         || v147->mem1_23\n         || *(_DWORD *)&v147->mem1_0\n         || v147->mem1_21;\n      v162 = v22;\n      if ( v22 )\n        v23 = 256;\n      else\n        v23 = 0;\n      v171 = v23;\n      if ( (unsigned int)sub_6B6A(-100, name, &v191, v23) )\n      {\n        if ( *__errno_location() != 40 || !v147->mem1_22 )\n        {\n          if ( *__errno_location() != 2 )\n          {\n            v24 = sub_13BE4(4u, (__int64)name);\n            v25 = gettext(\"cannot stat %s\");\n            v26 = __errno_location();\n            error(0, *v26, v25, v24);\n            return 0LL;\n          }\n          v151[0] = 1;\n        }\n      }\n      else\n      {\n        v159 = v162;\n        errnum = 17;\n      }\n    }\n    if ( errnum == 17 )\n    {\n      v154 = 0;\n      if ( *(_DWORD *)&v147->mem1_8 != 2 && !sub_947B(old, &v190, name, &v191, v147, &v154) )\n      {\n        v27 = sub_13B16(1u, 4u, (__int64)name);\n        v28 = sub_13B16(0, 4u, (__int64)old);\n        v29 = gettext(\"%s and %s are the same file\");\n        error(0, 0, v29, v28, v27);\n        return 0LL;\n      }\n      if ( v147->mem1_45 && (st_mode & 0xF000) != 0x4000 )\n      {\n        v30 = v147->mem1_31 && (v147->mem1_24 != 1 || v191.st_dev != v190.st_dev);\n        v172 = v30;\n        if ( (int)sub_1541B((__int64)name, (__int64)&v191, (__int64)&v190, v30) >= 0 )\n        {\n          if ( st_ino )\n            *st_ino = 1;\n          v176 = sub_D4B3((__int64)name, v190.st_ino, v190.st_dev);\n          if ( !v176 || (unsigned __int8)sub_A0AF(v176, (__int64)name, 1u, v147->mem1_46, v161) == 1 )\n            return 1LL;\n          goto LABEL_378;\n        }\n      }\n      if ( v147->mem1_24 )\n      {\n        if ( sub_9EEC(v147, name, (__int64)&v191) )\n        {\n          if ( st_ino )\n            *st_ino = 1;\n          return 1LL;\n        }\n      }\n      else if ( (st_mode & 0xF000) != 0x4000\n             && (*(_DWORD *)&v147->mem1_8 == 2\n              || *(_DWORD *)&v147->mem1_8 == 3 && !sub_9CF2((mystruct_2 *)v147, name, (mystruct_1 *)&v191)) )\n      {\n        return 1LL;\n      }\n      if ( v154 )\n        return 1LL;\n      if ( (v191.st_mode & 0xF000) != 0x4000 )\n      {\n        if ( (st_mode & 0xF000) == 0x4000 && (!v147->mem1_24 || !*(_DWORD *)&v147->mem1_0) )\n        {\n          v31 = sub_13B16(1u, 4u, (__int64)old);\n          v32 = sub_13B16(0, 4u, (__int64)name);\n          v33 = gettext(\"cannot overwrite non-directory %s with directory %s\");\n          error(0, 0, v33, v32, v31);\n          return 0LL;\n        }\n        if ( v150\n          && *(_DWORD *)&v147->mem1_0 != 3\n          && sub_FD2F(*(_QWORD *)&v147->mem1_64, (__int64)name, (__int64 *)&v191) )\n        {\n          v34 = sub_13B16(1u, 4u, (__int64)old);\n          v35 = sub_13B16(0, 4u, (__int64)name);\n          v36 = gettext(\"will not overwrite just-created %s with %s\");\n          error(0, 0, v36, v35, v34);\n          return 0LL;\n        }\n      }\n      if ( (st_mode & 0xF000) != 0x4000\n        && (v191.st_mode & 0xF000) == 0x4000\n        && (!v147->mem1_24 || !*(_DWORD *)&v147->mem1_0) )\n      {\n        v37 = sub_13BE4(4u, (__int64)name);\n        v38 = gettext(\"cannot overwrite directory %s with non-directory\");\n        error(0, 0, v38, v37);\n        return 0LL;\n      }\n      if ( v147->mem1_24\n        && (v190.st_mode & 0xF000) == 0x4000\n        && (v191.st_mode & 0xF000) != 0x4000\n        && !*(_DWORD *)&v147->mem1_0 )\n      {\n        v39 = sub_13D76(0, 3u, (__int64)name);\n        v40 = sub_13D76(0, 3u, (__int64)old);\n        v41 = gettext(\"cannot move directory onto non-directory: %s -> %s\");\n        error(0, 0, v41, v40, v39);\n        return 0LL;\n      }\n      if ( *(_DWORD *)&v147->mem1_0\n        && (v180 = (mystruct_1 *)sub_F9B9(old), !sub_6905(v180))\n        && (v147->mem1_24 || (v191.st_mode & 0xF000) != 0x4000) )\n      {\n        if ( *(_DWORD *)&v147->mem1_0 != 3 && sub_A210(&v180->mem1_0, (mystruct_1 *)&v190, name) )\n        {\n          if ( v147->mem1_24 )\n            v42 = gettext(\"backing up %s might destroy source;  %s not moved\");\n          else\n            v42 = gettext(\"backing up %s might destroy source;  %s not copied\");\n          format = v42;\n          v43 = sub_13B16(1u, 4u, (__int64)old);\n          v44 = sub_13B16(0, 4u, (__int64)name);\n          error(0, 0, format, v44, v43);\n          return 0LL;\n        }\n        ptr = sub_F3F4(0xFFFFFF9C, name, *(_DWORD *)&v147->mem1_0);\n        if ( ptr )\n        {\n          s = (char *)ptr;\n          v45 = strlen((const char *)ptr);\n          n = v45 + 1;\n          v46 = 16 * ((v45 + 24) / 0x10);\n          while ( &v143 != (mystruct_2 **)((char *)&v143 - (v46 & 0xFFFFFFFFFFFFF000LL)) )\n            ;\n          v47 = alloca(v46 & 0xFFF);\n          if ( (v46 & 0xFFF) != 0 )\n            *(mystruct_2 **)((char *)&v143 + (v46 & 0xFFF) - 8) = *(mystruct_2 **)((char *)&v143 + (v46 & 0xFFF) - 8);\n          dest = &v143;\n          v177 = (char *)memcpy(&v143, s, n);\n          free(ptr);\n        }\n        else if ( *__errno_location() != 2 )\n        {\n          v48 = sub_13BE4(4u, (__int64)name);\n          v49 = gettext(\"cannot backup %s\");\n          v50 = __errno_location();\n          error(0, *v50, v49, v48);\n          return 0LL;\n        }\n        v151[0] = 1;\n      }\n      else if ( (v191.st_mode & 0xF000) != 0x4000\n             && v147->mem1_24 != 1\n             && (v147->mem1_21\n              || v147->mem1_34 && v191.st_nlink > 1\n              || *(_DWORD *)&v147->mem1_4 == 2 && (v190.st_mode & 0xF000) != 0x8000) )\n      {\n        if ( unlink(name) && *__errno_location() != 2 )\n        {\n          v51 = sub_13BE4(4u, (__int64)name);\n          v52 = gettext(\"cannot remove %s\");\n          v53 = __errno_location();\n          error(0, *v53, v52, v51);\n          return 0LL;\n        }\n        v151[0] = 1;\n        if ( v147->mem1_46 )\n        {\n          v54 = sub_13BE4(4u, (__int64)name);\n          v55 = gettext(\"removed %s\\n\");\n          printf(v55, v54);\n        }\n      }\n    }\n  }\n  if ( v150 && *(_QWORD *)&v147->mem1_64 && v147->mem1_24 != 1 && !*(_DWORD *)&v147->mem1_0 )\n  {\n    v160 = 1;\n    if ( v159 )\n    {\n      v178 = &v191;\n    }\n    else if ( lstat(name, &v193) )\n    {\n      v160 = 0;\n    }\n    else\n    {\n      v178 = &v193;\n    }\n    if ( v160\n      && (v178->st_mode & 0xF000) == 40960\n      && sub_FD2F(*(_QWORD *)&v147->mem1_64, (__int64)name, (__int64 *)v178) )\n    {\n      v56 = sub_13B16(1u, 4u, (__int64)name);\n      v57 = sub_13B16(0, 4u, (__int64)old);\n      v58 = gettext(\"will not copy %s through just-created symlink %s\");\n      error(0, 0, v58, v57, v56);\n      return 0LL;\n    }\n  }\n  if ( v147->mem1_46 && v147->mem1_24 != 1 && (st_mode & 0xF000) != 0x4000 )\n    sub_9FB3((__int64)old, (__int64)name, (__int64)v177);\n  if ( !errnum )\n  {\n    v176 = 0LL;\n    goto LABEL_172;\n  }\n  if ( v147->mem1_42 && (st_mode & 0xF000) == 0x4000 )\n  {\n    if ( !v150 )\n    {\nLABEL_162:\n      v176 = sub_D43A(v190.st_ino, v190.st_dev);\n      goto LABEL_172;\n    }\nLABEL_171:\n    v176 = sub_D4B3((__int64)name, v190.st_ino, v190.st_dev);\n    goto LABEL_172;\n  }\n  if ( v147->mem1_24 && v190.st_nlink == 1 )\n    goto LABEL_162;\n  if ( v147->mem1_34\n    && v147->mem1_23 != 1\n    && (v190.st_nlink > 1 || v150 && *(_DWORD *)&v147->mem1_4 == 3 || *(_DWORD *)&v147->mem1_4 == 4) )\n  {\n    goto LABEL_171;\n  }\nLABEL_172:\n  if ( v176 )\n  {\n    if ( (st_mode & 0xF000) != 0x4000 )\n    {\n      if ( (unsigned __int8)sub_A0AF(v176, (__int64)name, 1u, v147->mem1_46, v161) == 1 )\n        return 1LL;\n      goto LABEL_378;\n    }\n    if ( (unsigned __int8)sub_144BD((__int64)old, v176) )\n    {\n      v59 = sub_13B16(1u, 4u, qword_241A8);\n      v60 = sub_13B16(0, 4u, qword_241A0);\n      v61 = gettext(\"cannot copy a directory, %s, into itself, %s\");\n      error(0, 0, v61, v60, v59);\n      *st_dev = 1;\nLABEL_378:\n      if ( v147->mem1_37 )\n        sub_A060();\n      if ( !v176 )\n        sub_D3BB(v190.st_ino, v190.st_dev);\n      if ( v177 )\n      {\n        if ( rename(v177, name) )\n        {\n          v137 = sub_13BE4(4u, (__int64)name);\n          v138 = gettext(\"cannot un-backup %s\");\n          v139 = __errno_location();\n          error(0, *v139, v138, v137);\n        }\n        else if ( v147->mem1_46 )\n        {\n          v140 = sub_13B16(1u, 4u, (__int64)name);\n          v141 = sub_13B16(0, 4u, (__int64)v177);\n          v142 = gettext(\"%s -> %s (unbackup)\\n\");\n          printf(v142, v141, v140);\n        }\n      }\n      return 0LL;\n    }\n    if ( (unsigned __int8)sub_144BD((__int64)name, v176) )\n    {\n      v62 = sub_13BE4(4u, qword_241A0);\n      v63 = gettext(\"warning: source directory %s specified more than once\");\n      error(0, 0, v63, v62);\n      if ( v147->mem1_24 && st_ino )\n        *st_ino = 1;\n      return 1LL;\n    }\n    if ( *(_DWORD *)&v147->mem1_4 != 4 && (!v150 || *(_DWORD *)&v147->mem1_4 != 3) )\n    {\n      v64 = sub_13B16(1u, 4u, v176);\n      v65 = sub_13B16(0, 4u, (__int64)name);\n      v66 = gettext(\"will not create hard link %s to directory %s\");\n      error(0, 0, v66, v65, v64);\n      goto LABEL_378;\n    }\n  }\n  if ( v147->mem1_24 )\n  {\n    if ( errnum == 17 )\n    {\n      if ( rename(old, name) )\n        v67 = *__errno_location();\n      else\n        v67 = 0;\n      errnum = v67;\n    }\n    if ( !errnum )\n    {\n      if ( v147->mem1_46 )\n      {\n        v68 = gettext(\"renamed \");\n        printf(v68);\n        sub_9FB3((__int64)old, (__int64)name, (__int64)v177);\n      }\n      if ( v147->mem1_33 )\n        sub_8199((__int64)name, 0, 1u, v147);\n      if ( st_ino )\n        *st_ino = 1;\n      if ( v150 && v147->mem1_49 != 1 )\n        sub_FC8F(*(_QWORD *)&v147->mem1_64, (__int64)name, &v190);\n      return 1LL;\n    }\n    if ( errnum == 22 )\n    {\n      v69 = sub_13B16(1u, 4u, qword_241A8);\n      v70 = sub_13B16(0, 4u, qword_241A0);\n      v71 = gettext(\"cannot move %s to a subdirectory of itself, %s\");\n      error(0, 0, v71, v70, v69);\n      *st_dev = 1;\n      return 1LL;\n    }\n    if ( errnum != 18 )\n    {\n      v72 = sub_13B16(1u, 4u, (__int64)name);\n      v73 = sub_13B16(0, 4u, (__int64)old);\n      v74 = gettext(\"cannot move %s to %s\");\n      error(0, errnum, v74, v73, v72);\n      sub_D3BB(v190.st_ino, v190.st_dev);\n      return 0LL;\n    }\n    if ( (st_mode & 0xF000) == 0x4000 )\n      v75 = rmdir(name) != 0;\n    else\n      v75 = unlink(name) != 0;\n    if ( v75 && *__errno_location() != 2 )\n    {\n      v76 = sub_13B16(1u, 4u, (__int64)name);\n      v77 = sub_13B16(0, 4u, (__int64)old);\n      v78 = gettext(\"inter-device move failed: %s to %s; unable to remove target\");\n      v79 = __errno_location();\n      error(0, *v79, v78, v77, v76);\n      sub_D3BB(v190.st_ino, v190.st_dev);\n      return 0LL;\n    }\n    if ( v147->mem1_46 && (st_mode & 0xF000) != 0x4000 )\n    {\n      v80 = gettext(\"copied \");\n      printf(v80);\n      sub_9FB3((__int64)old, (__int64)name, (__int64)v177);\n    }\n    v151[0] = 1;\n  }\n  if ( v147->mem1_43 )\n    v81 = *(_DWORD *)&v147->mem1_16 & 0xFFF;\n  else\n    v81 = st_mode & 0xFFF;\n  v173 = v81;\n  if ( v147->mem1_29 != 1 )\n  {\n    if ( (st_mode & 0xF000) == 0x4000 )\n      v82 = 18;\n    else\n      v82 = 0;\n  }\n  else\n  {\n    v82 = 63;\n  }\n  v167 = v173 & v82;\n  v156 = 1;\n  v83 = name;\n  if ( (unsigned __int8)sub_7F19((__int64)old, (__int64)name, st_mode, v151[0], v147) != 1 )\n    return 0LL;\n  if ( (st_mode & 0xF000) == 0x4000 )\n  {\n    if ( (unsigned __int8)sub_78E1((mystruct_1 *)&v190, v148) )\n    {\n      v84 = sub_13BE4(4u, (__int64)old);\n      v85 = gettext(\"cannot copy cyclic symbolic link %s\");\n      error(0, 0, v85, v84);\n      goto LABEL_378;\n    }\n    v86 = alloca(32LL);\n    v189 = &v143;\n    v143 = v148;\n    st_ino = (_BYTE *)v190.st_ino;\n    st_dev = (bool *)v190.st_dev;\n    if ( !v151[0] && (v191.st_mode & 0xF000) == 0x4000 )\n    {\n      v167 = 0;\n      if ( (v147->mem1_33 || v147->mem1_37)\n        && (unsigned __int8)sub_8199((__int64)name, v147->mem1_37, 0, v147) != 1\n        && v147->mem1_38 )\n      {\n        goto LABEL_378;\n      }\n    }\n    else\n    {\n      if ( mkdir(name, v173 & ~v167) )\n      {\n        v87 = sub_13BE4(4u, (__int64)name);\n        v88 = gettext(\"cannot create directory %s\");\n        v89 = __errno_location();\n        error(0, *v89, v88, v87);\n        goto LABEL_378;\n      }\n      if ( lstat(name, &v191) )\n      {\n        v90 = sub_13BE4(4u, (__int64)name);\n        v91 = gettext(\"cannot stat %s\");\n        v92 = __errno_location();\n        error(0, *v92, v91, v90);\n        goto LABEL_378;\n      }\n      if ( (v191.st_mode & 0x1C0) != 448 )\n      {\n        v166 = v191.st_mode;\n        v155 = 1;\n        if ( lchmod(name, v191.st_mode | 0x1C0) )\n        {\n          v93 = sub_13BE4(4u, (__int64)name);\n          v94 = gettext(\"setting permissions for %s\");\n          v95 = __errno_location();\n          error(0, *v95, v94, v93);\n          goto LABEL_378;\n        }\n      }\n      if ( !*v146 )\n      {\n        sub_D4B3((__int64)name, v191.st_ino, v191.st_dev);\n        *v146 = 1;\n      }\n      if ( v147->mem1_46 )\n      {\n        if ( v147->mem1_24 )\n        {\n          v96 = sub_13BE4(4u, (__int64)name);\n          v97 = gettext(\"created directory %s\\n\");\n          printf(v97, v96);\n        }\n        else\n        {\n          sub_9FB3((__int64)old, (__int64)name, 0LL);\n        }\n      }\n    }\n    if ( !v147->mem1_28 || !v149 || *v149 == v190.st_dev )\n      v156 = sub_7985((__int64)old, (__int64)name, v151[0], &v190, v189, v147, v146, st_dev);\n  }\n  else if ( v147->mem1_44 )\n  {\n    v158 = 1;\n    if ( *old != 47 )\n    {\n      s2 = (char *)sub_F867((__int64)name, (__int64)v83);\n      v98 = !strcmp(\".\", s2)\n         || stat(\".\", &v192)\n         || stat(s2, &v193)\n         || v192.st_ino == v193.st_ino && v192.st_dev == v193.st_dev;\n      v164 = v98;\n      free(s2);\n      if ( !v164 )\n      {\n        v99 = sub_13D76(0, 3u, (__int64)name);\n        v100 = gettext(\"%s: can make relative symbolic links only in current directory\");\n        error(0, 0, v100, v99);\n        goto LABEL_378;\n      }\n    }\n    v174 = sub_E0A3(old, -100, name, v147->mem1_22, -1);\n    if ( v174 > 0 )\n    {\n      v101 = sub_13B16(1u, 4u, (__int64)old);\n      v102 = sub_13B16(0, 4u, (__int64)name);\n      v103 = gettext(\"cannot create symbolic link %s to %s\");\n      error(0, v174, v103, v102, v101);\n      goto LABEL_378;\n    }\n  }\n  else if ( v147->mem1_23 )\n  {\n    v104 = v147->mem1_22 || *(_DWORD *)&v147->mem1_8 == 3;\n    v163 = v104;\n    if ( (unsigned __int8)sub_A0AF((__int64)old, (__int64)name, v104, 0, v161) != 1 )\n      goto LABEL_378;\n  }\n  else if ( (st_mode & 0xF000) == 0x8000 || v147->mem1_20 && (st_mode & 0xF000) != 40960 )\n  {\n    v157 = 1;\n    if ( (unsigned __int8)sub_8348(old, name, v147, v173 & 0x1FF, v167, v151, (mystruct_2 *)&v190) != 1 )\n      goto LABEL_378;\n  }\n  else\n  {\n    switch ( st_mode & 0xF000 )\n    {\n      case 0x1000u:\n        if ( sub_17971(name, st_mode & ~v167, 0LL) )\n        {\n          v105 = st_mode & ~v167;\n          BYTE1(v105) &= ~0x10u;\n          if ( mkfifo(name, v105) )\n          {\n            v106 = sub_13BE4(4u, (__int64)name);\n            v107 = gettext(\"cannot create fifo %s\");\n            v108 = __errno_location();\n            error(0, *v108, v107, v106);\n            goto LABEL_378;\n          }\n        }\n        break;\n      case 0x6000u:\n      case 0x2000u:\n      case 0xC000u:\n        if ( sub_17971(name, st_mode & ~v167, v190.st_rdev) )\n        {\n          v109 = sub_13BE4(4u, (__int64)name);\n          v110 = gettext(\"cannot create special file %s\");\n          v111 = __errno_location();\n          error(0, *v111, v110, v109);\n          goto LABEL_378;\n        }\n        break;\n      case 0xA000u:\n        v186 = sub_E3B3(old, v190.st_size);\n        v158 = 1;\n        if ( !v186 )\n        {\n          v112 = sub_13BE4(4u, (__int64)old);\n          v113 = gettext(\"cannot read symbolic link %s\");\n          v114 = __errno_location();\n          error(0, *v114, v113, v112);\n          goto LABEL_378;\n        }\n        v169 = sub_E0A3(v186, -100, name, v147->mem1_22, -1);\n        if ( v169 > 0 )\n        {\n          if ( v147->mem1_45 )\n          {\n            if ( v151[0] != 1 && (v191.st_mode & 0xF000) == 40960 )\n            {\n              st_size = v191.st_size;\n              if ( st_size == strlen(v186) )\n              {\n                s1 = sub_E3B3(name, v191.st_size);\n                if ( s1 )\n                {\n                  if ( !strcmp(s1, v186) )\n                    v169 = 0;\n                  free(s1);\n                }\n              }\n            }\n          }\n        }\n        free(v186);\n        if ( v169 > 0 )\n        {\n          v116 = sub_13BE4(4u, (__int64)name);\n          v117 = gettext(\"cannot create symbolic link %s\");\n          error(0, v169, v117, v116);\n          goto LABEL_378;\n        }\n        if ( v147->mem1_37 )\n          sub_A060();\n        if ( v147->mem1_29 )\n        {\n          if ( lchown(name, v190.st_uid, v190.st_gid) )\n          {\n            if ( !sub_D236((__int64)v147) )\n            {\n              v118 = gettext(\"failed to preserve ownership for %s\");\n              v119 = __errno_location();\n              error(0, *v119, v118, name);\n              if ( v147->mem1_36 )\n                goto LABEL_378;\n            }\n          }\n        }\n        break;\n      default:\n        v120 = sub_13BE4(4u, (__int64)old);\n        v121 = gettext(\"%s has unknown file type\");\n        error(0, 0, v121, v120);\n        goto LABEL_378;\n    }\n  }\n  if ( v151[0] != 1\n    && v147->mem1_20 != 1\n    && (st_mode & 0xF000) != 0x4000\n    && (v147->mem1_33 || v147->mem1_37)\n    && (unsigned __int8)sub_8199((__int64)name, v147->mem1_37, 0, v147) != 1\n    && v147->mem1_38 )\n  {\n    goto LABEL_378;\n  }\n  if ( v150 && *(_QWORD *)&v147->mem1_64 && !lstat(name, &v193) )\n    sub_FC8F(*(_QWORD *)&v147->mem1_64, (__int64)name, &v193);\n  if ( v147->mem1_23 && (st_mode & 0xF000) != 0x4000 )\n    return v156;\n  if ( v157 )\n    return v156;\n  if ( v147->mem1_31 )\n  {\n    v193.st_dev = sub_14E7E((__int64)&v190);\n    v193.st_ino = v122;\n    v193.st_nlink = sub_14EB2((__int64)&v190);\n    *(_QWORD *)&v193.st_mode = v123;\n    if ( v158 ? (unsigned int)sub_6BE5((__int64)name, (__int64)&v193) != 0 : sub_16669(name, (__int64 *)&v193) != 0 )\n    {\n      v125 = sub_13BE4(4u, (__int64)name);\n      v126 = gettext(\"preserving times for %s\");\n      v127 = __errno_location();\n      error(0, *v127, v126, v125);\n      if ( v147->mem1_36 )\n        return 0LL;\n    }\n  }\n  if ( v158 != 1 && v147->mem1_29 && (v151[0] || v190.st_uid != v191.st_uid || v190.st_gid != v191.st_gid) )\n  {\n    v128 = sub_7C6A((mystruct_2 *)v147, name, 0xFFFFFFFF, (mystruct_1 *)&v190, v151[0], (mystruct_3 *)&v191);\n    if ( v128 == -1 )\n      return 0LL;\n    if ( !v128 )\n      st_mode &= 0xFFFFF1FF;\n  }\n  if ( v147->mem1_39 && (unsigned __int8)sub_7964(old, 0xFFFFFFFFLL, name, 0xFFFFFFFFLL, v147) != 1 && v147->mem1_40 )\n    return 0LL;\n  if ( v158 )\n    return v156;\n  sub_7F03();\n  if ( v147->mem1_30 || v147->mem1_24 )\n  {\n    if ( (unsigned int)sub_E265((__int64)old, 0xFFFFFFFF, (__int64)name, 0xFFFFFFFF, st_mode) && v147->mem1_36 )\n      return 0LL;\n  }\n  else if ( v147->mem1_43 )\n  {\n    if ( (unsigned int)sub_E332((__int64)name, 0xFFFFFFFF, *(_DWORD *)&v147->mem1_16) )\n      return 0LL;\n  }\n  else if ( v147->mem1_32 && v151[0] )\n  {\n    if ( (st_mode & 0xF000) == 0x4000 || (st_mode & 0xF000) == 49152 )\n      v129 = 511;\n    else\n      v129 = 438;\n    v175 = v129;\n    v130 = sub_D2C6();\n    if ( (unsigned int)sub_E332((__int64)name, 0xFFFFFFFF, v175 & (unsigned int)~v130) )\n      return 0LL;\n  }\n  else\n  {\n    if ( v167 )\n    {\n      v167 &= ~(unsigned int)sub_D2C6();\n      if ( v167 )\n      {\n        if ( v155 != 1 )\n        {\n          if ( v151[0] && lstat(name, &v191) )\n          {\n            v131 = sub_13BE4(4u, (__int64)name);\n            v132 = gettext(\"cannot stat %s\");\n            v133 = __errno_location();\n            error(0, *v133, v132, v131);\n            return 0LL;\n          }\n          v166 = v191.st_mode;\n          if ( (v167 & ~v191.st_mode) != 0 )\n            v155 = 1;\n        }\n      }\n    }\n    if ( v155 )\n    {\n      if ( lchmod(name, v167 | v166) )\n      {\n        v134 = sub_13BE4(4u, (__int64)name);\n        v135 = gettext(\"preserving permissions for %s\");\n        v136 = __errno_location();\n        error(0, *v136, v135, v134);\n        if ( v147->mem1_36 )\n          return 0LL;\n      }\n    }\n  }\n  return v156;\n}\n",
  "0xcf79": "__int64 __fastcall sub_CF79(mystruct_1 *a1)\n{\n  if ( !a1 )\n    __assert_fail(\"co != NULL\", \"../src/copy.c\", 0xBAAu, \"valid_options\");\n  if ( *(_DWORD *)&a1->mem1_0 > 3u )\n    __assert_fail(\"VALID_BACKUP_TYPE (co->backup_type)\", \"../src/copy.c\", 0xBABu, \"valid_options\");\n  if ( *(_DWORD *)&a1->mem1_12 != 1 && *(_DWORD *)&a1->mem1_12 != 2 && *(_DWORD *)&a1->mem1_12 != 3 )\n    __assert_fail(\"VALID_SPARSE_MODE (co->sparse_mode)\", \"../src/copy.c\", 0xBACu, \"valid_options\");\n  if ( *(_DWORD *)&a1->mem1_56 >= 3u )\n    __assert_fail(\"VALID_REFLINK_MODE (co->reflink_mode)\", \"../src/copy.c\", 0xBADu, \"valid_options\");\n  if ( a1->mem1_23 == 1 && a1->mem1_44 == 1 )\n    __assert_fail(\"!(co->hard_link && co->symbolic_link)\", \"../src/copy.c\", 0xBAEu, \"valid_options\");\n  if ( *(_DWORD *)&a1->mem1_56 == 2 && *(_DWORD *)&a1->mem1_12 != 2 )\n    __assert_fail(\n      \"! (co->reflink_mode == REFLINK_ALWAYS && co->sparse_mode != SPARSE_AUTO)\",\n      \"../src/copy.c\",\n      0xBAFu,\n      \"valid_options\");\n  return 1LL;\n}\n",
  "0xd1e2": "mystruct_1 *__fastcall sub_D1E2(mystruct_1 *a1)\n{\n  mystruct_1 *result; // rax\n\n  memset(a1, 0, 0x50uLL);\n  a1->mem1_27 = geteuid() == 0;\n  a1->mem1_26 = a1->mem1_27;\n  result = a1;\n  *(_DWORD *)&a1->mem1_52 = -1;\n  return result;\n}\n",
  "0xd236": "_BOOL8 __fastcall sub_D236(mystruct_1 *a1)\n{\n  return (*__errno_location() == 1 || *__errno_location() == 22) && a1->mem1_26 != 1;\n}\n",
  "0xd27e": "_BOOL8 __fastcall sub_D27E(mystruct_1 *a1)\n{\n  return (*__errno_location() == 1 || *__errno_location() == 22) && a1->mem1_27 != 1;\n}\n",
  "0xd32b": "_BOOL8 __fastcall sub_D32B(mystruct_1 *a1, mystruct_2 *a2)\n{\n  return *(_QWORD *)&a1->mem1_0 == *(_QWORD *)&a2->mem2_0 && *(_QWORD *)&a1->mem1_8 == *(_QWORD *)&a2->mem2_8;\n}\n",
  "0xd43a": "__int64 __fastcall sub_D43A(__int64 a1, __int64 a2)\n{\n  mystruct_1 *v3; // [rsp+18h] [rbp-28h]\n  __int64 v4[4]; // [rsp+20h] [rbp-20h] BYREF\n\n  v4[3] = __readfsqword(0x28u);\n  v4[0] = a1;\n  v4[1] = a2;\n  v3 = (mystruct_1 *)sub_10569(qword_245E0, (__int64)v4);\n  if ( v3 )\n    return *(_QWORD *)&v3->mem1_16;\n  else\n    return 0LL;\n}\n",
  "0xd4b3": "__int64 __fastcall sub_D4B3(const char *a1, __int64 a2, __int64 a3)\n{\n  mystruct_1 *v5; // [rsp+20h] [rbp-10h]\n  mystruct_2 *v6; // [rsp+28h] [rbp-8h]\n\n  v5 = (mystruct_1 *)sub_1745E(0x18uLL, a2);\n  *(_QWORD *)&v5->mem1_16 = sub_175EA(a1);\n  *(_QWORD *)&v5->mem1_0 = a2;\n  *(_QWORD *)&v5->mem1_8 = a3;\n  v6 = (mystruct_2 *)sub_1195F((_QWORD *)qword_245E0, (__int64)v5);\n  if ( !v6 )\n    sub_1761B();\n  if ( v6 == (mystruct_2 *)v5 )\n    return 0LL;\n  sub_D384((void **)v5);\n  return *(_QWORD *)&v6->mem2_16;\n}\n",
  "0xd5ca": "mystruct_1 *__fastcall sub_D5CA(int a1, mystruct_1 *a2)\n{\n  int v2; // edx\n  mystruct_1 *result; // rax\n\n  *(_DWORD *)&a2->mem1_0 = a1;\n  *(_QWORD *)&a2->mem1_24 = 0LL;\n  *(_QWORD *)&a2->mem1_40 = 0LL;\n  *(_QWORD *)&a2->mem1_8 = 0LL;\n  a2->mem1_32 = 0;\n  a2->mem1_33 = 0;\n  v2 = (unsigned __int8)sub_D5BB();\n  result = a2;\n  *(_DWORD *)&a2->mem1_16 = v2;\n  return result;\n}\n",
  "0xd62c": "bool __fastcall sub_D62C(mystruct_1 *a1)\n{\n  unsigned int v2; // [rsp+18h] [rbp-1048h]\n  unsigned int i; // [rsp+1Ch] [rbp-1044h]\n  mystruct_2 *v4; // [rsp+20h] [rbp-1040h]\n  __int64 v5; // [rsp+28h] [rbp-1038h]\n  unsigned __int64 v6; // [rsp+40h] [rbp-1020h]\n  unsigned __int64 v7; // [rsp+48h] [rbp-1018h]\n  __int64 s[2]; // [rsp+50h] [rbp-1010h] BYREF\n  int v9; // [rsp+60h] [rbp-1000h]\n  unsigned int v10; // [rsp+64h] [rbp-FFCh]\n  int v11; // [rsp+68h] [rbp-FF8h]\n  _QWORD v12[510]; // [rsp+70h] [rbp-FF0h] BYREF\n\n  v12[509] = __readfsqword(0x28u);\n  v2 = 0;\n  v4 = *(mystruct_2 **)&a1->mem1_40;\n  while ( 1 )\n  {\n    memset(s, 0, 0x1000uLL);\n    s[0] = *(_QWORD *)&a1->mem1_8;\n    v9 = *(_DWORD *)&a1->mem1_16;\n    v11 = 72;\n    s[1] = ~*(_QWORD *)&a1->mem1_8;\n    if ( ioctl(*(_DWORD *)&a1->mem1_0, 0xC020660BuLL, s) < 0 )\n      break;\n    if ( !v10 )\n    {\n      a1->mem1_33 = 1;\n      return *(_QWORD *)&a1->mem1_8 != 0LL;\n    }\n    if ( *(_QWORD *)&a1->mem1_24 > ~(unsigned __int64)v10 )\n      __assert_fail(\n        \"scan->ei_count <= SIZE_MAX - fiemap->fm_mapped_extents\",\n        \"../src/extent-scan.c\",\n        0x7Fu,\n        \"extent_scan_read\");\n    *(_QWORD *)&a1->mem1_24 += v10;\n    v6 = 0xAAAAAAAAAAAAAAABLL * (((__int64)v4 - *(_QWORD *)&a1->mem1_40) >> 3);\n    *(_QWORD *)&a1->mem1_40 = sub_17300(*(_QWORD *)&a1->mem1_40, *(_QWORD *)&a1->mem1_24, 0x18uLL);\n    v4 = (mystruct_2 *)(*(_QWORD *)&a1->mem1_40 + 24 * v6);\n    for ( i = 0; i < v10; ++i )\n    {\n      if ( v12[7 * i] > (unsigned __int64)(0x7FFFFFFFFFFFFFFFLL - v12[7 * i + 2]) )\n        __assert_fail(\n          \"fm_extents[i].fe_logical <= OFF_T_MAX - fm_extents[i].fe_length\",\n          \"../src/extent-scan.c\",\n          0x8Du,\n          \"extent_scan_read\");\n      if ( v2\n        && *(_DWORD *)&v4->mem2_16 == (v12[7 * i + 5] & 0xFFFFFFFE)\n        && *(_QWORD *)&v4->mem2_0 + *(_QWORD *)&v4->mem2_8 == v12[7 * i] )\n      {\n        *(_QWORD *)&v4->mem2_8 += v12[7 * i + 2];\n        *(_DWORD *)&v4->mem2_16 = v12[7 * i + 5];\n      }\n      else if ( (v2 || *(_QWORD *)&a1->mem1_8 <= v12[7 * i])\n             && (!v2 || *(_QWORD *)&v4->mem2_0 + *(_QWORD *)&v4->mem2_8 <= v12[7 * i]) )\n      {\n        v4 = (mystruct_2 *)(*(_QWORD *)&a1->mem1_40 + 24LL * v2);\n        *(_QWORD *)&v4->mem2_0 = v12[7 * i];\n        *(_QWORD *)&v4->mem2_8 = v12[7 * i + 2];\n        *(_DWORD *)&v4->mem2_16 = v12[7 * i + 5];\n        ++v2;\n      }\n      else\n      {\n        if ( v2 )\n          v5 = *(_QWORD *)&v4->mem2_0 + *(_QWORD *)&v4->mem2_8;\n        else\n          v5 = *(_QWORD *)&a1->mem1_8;\n        v7 = v5 - v12[7 * i];\n        if ( v7 < v12[7 * i + 2] )\n        {\n          if ( !*(_QWORD *)&a1->mem1_8 )\n            a1->mem1_32 = 1;\n          return 0;\n        }\n        v12[7 * i] = v5;\n        v12[7 * i-- + 2] -= v7;\n      }\n    }\n    if ( (*(_DWORD *)&v4->mem2_16 & 1) != 0 )\n      a1->mem1_33 = 1;\n    if ( v2 > 0x48 && a1->mem1_33 != 1 )\n      v4 = (mystruct_2 *)(*(_QWORD *)&a1->mem1_40 + 24LL * --v2 - 24);\n    *(_QWORD *)&a1->mem1_24 = v2;\n    if ( !a1->mem1_33 )\n    {\n      *(_QWORD *)&a1->mem1_8 = *(_QWORD *)&v4->mem2_8 + *(_QWORD *)&v4->mem2_0;\n      if ( v2 <= 0x47 )\n        continue;\n    }\n    return 1;\n  }\n  if ( !*(_QWORD *)&a1->mem1_8 )\n    a1->mem1_32 = 1;\n  return 0;\n}\n",
  "0xfc8f": "void __fastcall sub_FC8F(_QWORD *a1, const char *a2, mystruct_1 *a3)\n{\n  mystruct_2 *v4; // [rsp+20h] [rbp-10h]\n  mystruct_2 *v5; // [rsp+28h] [rbp-8h]\n\n  if ( a1 )\n  {\n    v4 = (mystruct_2 *)sub_1745E(0x18uLL, (__int64)a2);\n    *(_QWORD *)&v4->mem2_0 = sub_175EA(a2);\n    *(_QWORD *)&v4->mem2_8 = *(_QWORD *)&a3->mem1_8;\n    *(_QWORD *)&v4->mem2_16 = *(_QWORD *)&a3->mem1_0;\n    v5 = (mystruct_2 *)sub_1195F(a1, (__int64)v4);\n    if ( !v5 )\n      sub_1761B();\n    if ( v5 != v4 )\n      sub_11E4B((void **)v4);\n  }\n}\n",
  "0xfd2f": "bool __fastcall sub_FD2F(__int64 a1, __int64 a2, mystruct_1 *a3)\n{\n  __int64 v4[4]; // [rsp+20h] [rbp-20h] BYREF\n\n  v4[3] = __readfsqword(0x28u);\n  if ( !a1 )\n    return 0;\n  v4[0] = a2;\n  v4[1] = *(_QWORD *)&a3->mem1_8;\n  v4[2] = *(_QWORD *)&a3->mem1_0;\n  return sub_10569(a1, (__int64)v4) != 0;\n}\n",
  "0xfe61": "char *__fastcall sub_FE61(__int16 a1, mystruct_1 *a2)\n{\n  char v2; // dl\n  char v3; // dl\n  char v4; // al\n  char v5; // dl\n  char v6; // dl\n  char v7; // al\n  char v8; // dl\n  char v9; // dl\n  char v10; // al\n  char *result; // rax\n\n  a2->mem1_0 = sub_FDB2(a1);\n  if ( (a1 & 0x100) != 0 )\n    v2 = 114;\n  else\n    v2 = 45;\n  a2->mem1_1 = v2;\n  if ( (a1 & 0x80) != 0 )\n    v3 = 119;\n  else\n    v3 = 45;\n  a2->mem1_2 = v3;\n  if ( (a1 & 0x800) != 0 )\n  {\n    if ( (a1 & 0x40) != 0 )\n      v4 = 115;\n    else\n      v4 = 83;\n  }\n  else if ( (a1 & 0x40) != 0 )\n  {\n    v4 = 120;\n  }\n  else\n  {\n    v4 = 45;\n  }\n  a2->mem1_3 = v4;\n  if ( (a1 & 0x20) != 0 )\n    v5 = 114;\n  else\n    v5 = 45;\n  a2->mem1_4 = v5;\n  if ( (a1 & 0x10) != 0 )\n    v6 = 119;\n  else\n    v6 = 45;\n  a2->mem1_5 = v6;\n  if ( (a1 & 0x400) != 0 )\n  {\n    if ( (a1 & 8) != 0 )\n      v7 = 115;\n    else\n      v7 = 83;\n  }\n  else if ( (a1 & 8) != 0 )\n  {\n    v7 = 120;\n  }\n  else\n  {\n    v7 = 45;\n  }\n  a2->mem1_6 = v7;\n  if ( (a1 & 4) != 0 )\n    v8 = 114;\n  else\n    v8 = 45;\n  a2->mem1_7 = v8;\n  if ( (a1 & 2) != 0 )\n    v9 = 119;\n  else\n    v9 = 45;\n  a2->mem1_8 = v9;\n  if ( (a1 & 0x200) != 0 )\n  {\n    if ( (a1 & 1) != 0 )\n      v10 = 116;\n    else\n      v10 = 84;\n  }\n  else if ( (a1 & 1) != 0 )\n  {\n    v10 = 120;\n  }\n  else\n  {\n    v10 = 45;\n  }\n  a2->mem1_9 = v10;\n  a2->mem1_10 = 32;\n  result = &a2->mem1_11;\n  a2->mem1_11 = 0;\n  return result;\n}\n",
  "0x10265": "__int64 __fastcall sub_10265(mystruct_1 *a1)\n{\n  return *(_QWORD *)&a1->mem1_16;\n}\n",
  "0x1027b": "__int64 __fastcall sub_1027B(mystruct_1 *a1)\n{\n  return *(_QWORD *)&a1->mem1_24;\n}\n",
  "0x10291": "__int64 __fastcall sub_10291(mystruct_1 *a1)\n{\n  return *(_QWORD *)&a1->mem1_32;\n}\n",
  "0x102a7": "unsigned __int64 __fastcall sub_102A7(mystruct_1 *a1)\n{\n  mystruct_2 *i; // [rsp+8h] [rbp-20h]\n  unsigned __int64 v3; // [rsp+10h] [rbp-18h]\n  mystruct_2 *v4; // [rsp+18h] [rbp-10h]\n  unsigned __int64 j; // [rsp+20h] [rbp-8h]\n\n  v3 = 0LL;\n  for ( i = *(mystruct_2 **)&a1->mem1_0; (unsigned __int64)i < *(_QWORD *)&a1->mem1_8; i = (mystruct_2 *)((char *)i + 16) )\n  {\n    if ( *(_QWORD *)&i->mem2_0 )\n    {\n      v4 = i;\n      for ( j = 1LL; ; ++j )\n      {\n        v4 = *(mystruct_2 **)&v4->mem2_8;\n        if ( !v4 )\n          break;\n      }\n      if ( j > v3 )\n        v3 = j;\n    }\n  }\n  return v3;\n}\n",
  "0x10329": "_BOOL8 __fastcall sub_10329(mystruct_1 *a1)\n{\n  mystruct_2 *i; // [rsp+8h] [rbp-20h]\n  __int64 v3; // [rsp+10h] [rbp-18h]\n  __int64 v4; // [rsp+18h] [rbp-10h]\n  mystruct_2 *v5; // [rsp+20h] [rbp-8h]\n\n  v3 = 0LL;\n  v4 = 0LL;\n  for ( i = *(mystruct_2 **)&a1->mem1_0; (unsigned __int64)i < *(_QWORD *)&a1->mem1_8; i = (mystruct_2 *)((char *)i + 16) )\n  {\n    if ( *(_QWORD *)&i->mem2_0 )\n    {\n      v5 = i;\n      ++v3;\n      ++v4;\n      while ( 1 )\n      {\n        v5 = *(mystruct_2 **)&v5->mem2_8;\n        if ( !v5 )\n          break;\n        ++v4;\n      }\n    }\n  }\n  return v3 == *(_QWORD *)&a1->mem1_24 && v4 == *(_QWORD *)&a1->mem1_32;\n}\n",
  "0x1050e": "unsigned __int64 __fastcall sub_1050E(mystruct_1 *a1, __int64 a2)\n{\n  unsigned __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = (*(__int64 (__fastcall **)(__int64, _QWORD))&a1->mem1_48)(a2, *(_QWORD *)&a1->mem1_16);\n  if ( v3 >= *(_QWORD *)&a1->mem1_16 )\n    abort();\n  return *(_QWORD *)&a1->mem1_0 + 16 * v3;\n}\n",
  "0x10569": "__int64 __fastcall sub_10569(mystruct_1 *a1, __int64 a2)\n{\n  mystruct_2 *i; // [rsp+10h] [rbp-10h]\n  mystruct_2 *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = (mystruct_2 *)sub_1050E(a1, a2);\n  if ( !*(_QWORD *)&v4->mem2_0 )\n    return 0LL;\n  for ( i = v4; i; i = *(mystruct_2 **)&i->mem2_8 )\n  {\n    if ( a2 == *(_QWORD *)&i->mem2_0\n      || (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))&a1->mem1_56)(a2, *(_QWORD *)&i->mem2_0) )\n    {\n      return *(_QWORD *)&i->mem2_0;\n    }\n  }\n  return 0LL;\n}\n",
  "0x10600": "__int64 __fastcall sub_10600(mystruct_1 *a1)\n{\n  unsigned __int64 i; // [rsp+18h] [rbp-8h]\n\n  if ( !*(_QWORD *)&a1->mem1_32 )\n    return 0LL;\n  for ( i = *(_QWORD *)&a1->mem1_0; ; i += 16LL )\n  {\n    if ( i >= *(_QWORD *)&a1->mem1_8 )\n      abort();\n    if ( *(_QWORD *)i )\n      break;\n  }\n  return *(_QWORD *)i;\n}\n",
  "0x10660": "__int64 __fastcall sub_10660(mystruct_1 *a1, __int64 a2)\n{\n  mystruct_2 *v3; // [rsp+10h] [rbp-10h]\n  mystruct_2 *v4; // [rsp+18h] [rbp-8h]\n\n  v3 = (mystruct_2 *)sub_1050E(a1, a2);\n  v4 = v3;\n  do\n  {\n    if ( a2 == *(_QWORD *)&v4->mem2_0 && *(_QWORD *)&v4->mem2_8 )\n      return **(_QWORD **)&v4->mem2_8;\n    v4 = *(mystruct_2 **)&v4->mem2_8;\n  }\n  while ( v4 );\n  while ( 1 )\n  {\n    v3 = (mystruct_2 *)((char *)v3 + 16);\n    if ( (unsigned __int64)v3 >= *(_QWORD *)&a1->mem1_8 )\n      break;\n    if ( *(_QWORD *)&v3->mem2_0 )\n      return *(_QWORD *)&v3->mem2_0;\n  }\n  return 0LL;\n}\n",
  "0x106fe": "unsigned __int64 __fastcall sub_106FE(mystruct_1 *a1, __int64 a2, unsigned __int64 a3)\n{\n  unsigned __int64 v4; // rax\n  unsigned __int64 v5; // [rsp+20h] [rbp-18h]\n  mystruct_2 *i; // [rsp+28h] [rbp-10h]\n  mystruct_2 *j; // [rsp+30h] [rbp-8h]\n\n  v5 = 0LL;\n  for ( i = *(mystruct_2 **)&a1->mem1_0; (unsigned __int64)i < *(_QWORD *)&a1->mem1_8; i = (mystruct_2 *)((char *)i + 16) )\n  {\n    if ( *(_QWORD *)&i->mem2_0 )\n    {\n      for ( j = i; j; j = *(mystruct_2 **)&j->mem2_8 )\n      {\n        if ( v5 >= a3 )\n          return v5;\n        v4 = v5++;\n        *(_QWORD *)(a2 + 8 * v4) = *(_QWORD *)&j->mem2_0;\n      }\n    }\n  }\n  return v5;\n}\n",
  "0x1079e": "__int64 __fastcall sub_1079E(mystruct_1 *a1, unsigned __int8 (__fastcall *a2)(_QWORD, __int64), __int64 a3)\n{\n  __int64 v5; // [rsp+28h] [rbp-18h]\n  mystruct_2 *i; // [rsp+30h] [rbp-10h]\n  mystruct_2 *j; // [rsp+38h] [rbp-8h]\n\n  v5 = 0LL;\n  for ( i = *(mystruct_2 **)&a1->mem1_0; (unsigned __int64)i < *(_QWORD *)&a1->mem1_8; i = (mystruct_2 *)((char *)i + 16) )\n  {\n    if ( *(_QWORD *)&i->mem2_0 )\n    {\n      for ( j = i; j; j = *(mystruct_2 **)&j->mem2_8 )\n      {\n        if ( a2(*(_QWORD *)&j->mem2_0, a3) != 1 )\n          return v5;\n        ++v5;\n      }\n    }\n  }\n  return v5;\n}\n",
  "0x1094a": "mystruct_1 *__fastcall sub_1094A(mystruct_1 *a1)\n{\n  mystruct_1 *result; // rax\n\n  *(_DWORD *)&a1->mem1_0 = 0;\n  *(_DWORD *)&a1->mem1_4 = 1065353216;\n  *(_DWORD *)&a1->mem1_8 = 1061997773;\n  *(_DWORD *)&a1->mem1_12 = 1068826100;\n  result = a1;\n  a1->mem1_16 = 0;\n  return result;\n}\n",
  "0x109f8": "__int64 __fastcall sub_109F8(mystruct_1 *a1)\n{\n  mystruct_2 *v2; // [rsp+10h] [rbp-8h]\n\n  v2 = *(mystruct_2 **)&a1->mem1_40;\n  if ( v2 == (mystruct_2 *)&unk_1D820 )\n    return 1LL;\n  if ( *(float *)&v2->mem2_8 > 0.1\n    && (float)(1.0 - 0.1) > *(float *)&v2->mem2_8\n    && *(float *)&v2->mem2_12 > (float)(0.1 + 1.0)\n    && *(float *)&v2->mem2_0 >= 0.0\n    && *(float *)&v2->mem2_4 > (float)(*(float *)&v2->mem2_0 + 0.1)\n    && *(float *)&v2->mem2_4 <= 1.0\n    && *(float *)&v2->mem2_8 > (float)(*(float *)&v2->mem2_0 + 0.1) )\n  {\n    return 1LL;\n  }\n  *(_QWORD *)&a1->mem1_40 = &unk_1D820;\n  return 0LL;\n}\n",
  "0x10b05": "unsigned __int64 __fastcall sub_10B05(unsigned __int64 a1, mystruct_1 *a2)\n{\n  float v2; // xmm0_4\n  bool v4; // al\n  __int64 v5; // [rsp+8h] [rbp-18h]\n  unsigned __int64 v6; // [rsp+8h] [rbp-18h]\n  float v7; // [rsp+1Ch] [rbp-4h]\n\n  v5 = a1;\n  if ( a2->mem1_16 != 1 )\n  {\n    if ( (a1 & 0x8000000000000000LL) != 0LL )\n      v2 = (float)(int)(a1 & 1 | (a1 >> 1)) + (float)(int)(a1 & 1 | (a1 >> 1));\n    else\n      v2 = (float)(int)a1;\n    v7 = v2 / *(float *)&a2->mem1_8;\n    if ( v7 >= 1.8446744e19 )\n      return 0LL;\n    if ( v7 >= 9.223372e18 )\n      v5 = (unsigned int)(int)(float)(v7 - 9.223372e18) ^ 0x8000000000000000LL;\n    else\n      v5 = (unsigned int)(int)v7;\n  }\n  v6 = sub_108FF(v5);\n  v4 = v6 >> 61 != 0;\n  if ( (v6 & 0x1000000000000000LL) != 0 )\n    v4 = 1;\n  if ( v4 )\n    return 0LL;\n  else\n    return v6;\n}\n",
  "0x10c1e": "mystruct_1 *__fastcall sub_10C1E(\n        unsigned __int64 a1,\n        mystruct_1 *a2,\n        unsigned __int64 (__fastcall *a3)(__int64 a1, unsigned __int64 a2),\n        bool (__fastcall *a4)(__int64 a1, __int64 a2),\n        size_t a5)\n{\n  bool (__fastcall *v7)(__int64, __int64); // [rsp+10h] [rbp-30h]\n  unsigned __int64 (__fastcall *v8)(__int64, unsigned __int64); // [rsp+18h] [rbp-28h]\n  mystruct_1 *v9; // [rsp+20h] [rbp-20h]\n  mystruct_1 *ptr; // [rsp+38h] [rbp-8h]\n\n  v9 = a2;\n  v8 = a3;\n  v7 = a4;\n  if ( !a3 )\n    v8 = sub_109A0;\n  if ( !a4 )\n    v7 = sub_109DB;\n  ptr = (mystruct_1 *)malloc(0x50uLL);\n  if ( !ptr )\n    return 0LL;\n  if ( !a2 )\n    v9 = (mystruct_1 *)&unk_1D820;\n  *(_QWORD *)&ptr->mem1_40 = v9;\n  if ( (unsigned __int8)sub_109F8(ptr) == 1\n    && (*(_QWORD *)&ptr->mem1_16 = sub_10B05(a1, v9)) != 0LL\n    && (*(_QWORD *)&ptr->mem1_0 = calloc(*(_QWORD *)&ptr->mem1_16, 0x10uLL)) != 0LL )\n  {\n    *(_QWORD *)&ptr->mem1_8 = 16LL * *(_QWORD *)&ptr->mem1_16 + *(_QWORD *)&ptr->mem1_0;\n    *(_QWORD *)&ptr->mem1_24 = 0LL;\n    *(_QWORD *)&ptr->mem1_32 = 0LL;\n    *(_QWORD *)&ptr->mem1_48 = v8;\n    *(_QWORD *)&ptr->mem1_56 = v7;\n    *(_QWORD *)&ptr->mem1_64 = a5;\n    *(_QWORD *)&ptr->mem1_72 = 0LL;\n    return ptr;\n  }\n  else\n  {\n    free(ptr);\n    return 0LL;\n  }\n}\n",
  "0x10d93": "mystruct_1 *__fastcall sub_10D93(mystruct_1 *a1)\n{\n  mystruct_1 *result; // rax\n  mystruct_2 *i; // [rsp+18h] [rbp-18h]\n  mystruct_3 *j; // [rsp+20h] [rbp-10h]\n  mystruct_3 *v4; // [rsp+28h] [rbp-8h]\n\n  for ( i = *(mystruct_2 **)&a1->mem1_0; (unsigned __int64)i < *(_QWORD *)&a1->mem1_8; i = (mystruct_2 *)((char *)i + 16) )\n  {\n    if ( *(_QWORD *)&i->mem2_0 )\n    {\n      for ( j = *(mystruct_3 **)&i->mem2_8; j; j = v4 )\n      {\n        if ( *(_QWORD *)&a1->mem1_64 )\n          (*(void (__fastcall **)(_QWORD))&a1->mem1_64)(*(_QWORD *)&j->mem3_0);\n        *(_QWORD *)&j->mem3_0 = 0LL;\n        v4 = *(mystruct_3 **)&j->mem3_8;\n        *(_QWORD *)&j->mem3_8 = *(_QWORD *)&a1->mem1_72;\n        *(_QWORD *)&a1->mem1_72 = j;\n      }\n      if ( *(_QWORD *)&a1->mem1_64 )\n        (*(void (__fastcall **)(_QWORD))&a1->mem1_64)(*(_QWORD *)&i->mem2_0);\n      *(_QWORD *)&i->mem2_0 = 0LL;\n      *(_QWORD *)&i->mem2_8 = 0LL;\n    }\n  }\n  *(_QWORD *)&a1->mem1_24 = 0LL;\n  result = a1;\n  *(_QWORD *)&a1->mem1_32 = 0LL;\n  return result;\n}\n",
  "0x10e9e": "void __fastcall sub_10E9E(mystruct_1 *a1)\n{\n  mystruct_3 *i; // [rsp+18h] [rbp-18h]\n  mystruct_2 *j; // [rsp+18h] [rbp-18h]\n  mystruct_3 *ptr; // [rsp+20h] [rbp-10h]\n  mystruct_4 *ptra; // [rsp+20h] [rbp-10h]\n  mystruct_5 *ptrb; // [rsp+20h] [rbp-10h]\n  mystruct_4 *v6; // [rsp+28h] [rbp-8h]\n  mystruct_5 *v7; // [rsp+28h] [rbp-8h]\n\n  if ( *(_QWORD *)&a1->mem1_64 && *(_QWORD *)&a1->mem1_32 )\n  {\n    for ( i = *(mystruct_3 **)&a1->mem1_0; (unsigned __int64)i < *(_QWORD *)&a1->mem1_8; i = (mystruct_3 *)((char *)i + 16) )\n    {\n      if ( *(_QWORD *)&i->mem3_0 )\n      {\n        for ( ptr = i; ptr; ptr = *(mystruct_3 **)&ptr->mem3_8 )\n          (*(void (__fastcall **)(_QWORD))&a1->mem1_64)(*(_QWORD *)&ptr->mem3_0);\n      }\n    }\n  }\n  for ( j = *(mystruct_2 **)&a1->mem1_0; (unsigned __int64)j < *(_QWORD *)&a1->mem1_8; j = (mystruct_2 *)((char *)j + 16) )\n  {\n    for ( ptra = *(mystruct_4 **)&j->mem2_8; ptra; ptra = v6 )\n    {\n      v6 = *(mystruct_4 **)&ptra->mem4_8;\n      free(ptra);\n    }\n  }\n  for ( ptrb = *(mystruct_5 **)&a1->mem1_72; ptrb; ptrb = v7 )\n  {\n    v7 = *(mystruct_5 **)&ptrb->mem5_8;\n    free(ptrb);\n  }\n  free(*(void **)&a1->mem1_0);\n  free(a1);\n}\n",
  "0x10fcd": "mystruct_2 *__fastcall sub_10FCD(mystruct_1 *a1)\n{\n  mystruct_2 *v2; // [rsp+18h] [rbp-8h]\n\n  if ( !*(_QWORD *)&a1->mem1_72 )\n    return (mystruct_2 *)malloc(0x10uLL);\n  v2 = *(mystruct_2 **)&a1->mem1_72;\n  *(_QWORD *)&a1->mem1_72 = *(_QWORD *)&v2->mem2_8;\n  return v2;\n}\n",
  "0x1101c": "mystruct_1 *__fastcall sub_1101C(mystruct_1 *a1, mystruct_2 *a2)\n{\n  mystruct_1 *result; // rax\n\n  *(_QWORD *)&a2->mem2_0 = 0LL;\n  *(_QWORD *)&a2->mem2_8 = *(_QWORD *)&a1->mem1_72;\n  result = a1;\n  *(_QWORD *)&a1->mem1_72 = a2;\n  return result;\n}\n",
  "0x11056": "__int64 __fastcall sub_11056(mystruct_1 *a1, __int64 a2, mystruct_3 **a3, char a4)\n{\n  __int64 v5; // rdx\n  mystruct_2 *i; // [rsp+20h] [rbp-30h]\n  mystruct_3 *v9; // [rsp+28h] [rbp-28h]\n  __int64 v10; // [rsp+30h] [rbp-20h]\n  mystruct_4 *v11; // [rsp+38h] [rbp-18h]\n  __int64 v12; // [rsp+40h] [rbp-10h]\n  mystruct_5 *v13; // [rsp+48h] [rbp-8h]\n\n  v9 = (mystruct_3 *)sub_1050E(a1, a2);\n  *a3 = v9;\n  if ( !*(_QWORD *)&v9->mem3_0 )\n    return 0LL;\n  if ( a2 == *(_QWORD *)&v9->mem3_0\n    || (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))&a1->mem1_56)(a2, *(_QWORD *)&v9->mem3_0) )\n  {\n    v12 = *(_QWORD *)&v9->mem3_0;\n    if ( a4 )\n    {\n      if ( *(_QWORD *)&v9->mem3_8 )\n      {\n        v13 = *(mystruct_5 **)&v9->mem3_8;\n        v5 = *(_QWORD *)&v13->mem5_8;\n        *(_QWORD *)&v9->mem3_0 = *(_QWORD *)&v13->mem5_0;\n        *(_QWORD *)&v9->mem3_8 = v5;\n        sub_1101C(a1, (mystruct_2 *)v13);\n      }\n      else\n      {\n        *(_QWORD *)&v9->mem3_0 = 0LL;\n      }\n    }\n    return v12;\n  }\n  else\n  {\n    for ( i = (mystruct_2 *)v9; ; i = *(mystruct_2 **)&i->mem2_8 )\n    {\n      if ( !*(_QWORD *)&i->mem2_8 )\n        return 0LL;\n      if ( a2 == **(_QWORD **)&i->mem2_8\n        || (*(unsigned __int8 (__fastcall **)(__int64, _QWORD))&a1->mem1_56)(a2, **(_QWORD **)&i->mem2_8) )\n      {\n        break;\n      }\n    }\n    v10 = **(_QWORD **)&i->mem2_8;\n    if ( a4 )\n    {\n      v11 = *(mystruct_4 **)&i->mem2_8;\n      *(_QWORD *)&i->mem2_8 = *(_QWORD *)&v11->mem4_8;\n      sub_1101C(a1, (mystruct_2 *)v11);\n    }\n    return v10;\n  }\n}\n",
  "0x111ef": "__int64 __fastcall sub_111EF(mystruct_1 *a1, mystruct_2 *a2, char a3)\n{\n  mystruct_3 *i; // [rsp+20h] [rbp-30h]\n  mystruct_4 *j; // [rsp+28h] [rbp-28h]\n  __int64 v7; // [rsp+30h] [rbp-20h]\n  __int64 v8; // [rsp+30h] [rbp-20h]\n  mystruct_5 *v9; // [rsp+38h] [rbp-18h]\n  mystruct_6 *v10; // [rsp+38h] [rbp-18h]\n  mystruct_7 *v11; // [rsp+40h] [rbp-10h]\n  mystruct_4 *v12; // [rsp+48h] [rbp-8h]\n\n  for ( i = *(mystruct_3 **)&a2->mem2_0; (unsigned __int64)i < *(_QWORD *)&a2->mem2_8; i = (mystruct_3 *)((char *)i + 16) )\n  {\n    if ( *(_QWORD *)&i->mem3_0 )\n    {\n      for ( j = *(mystruct_4 **)&i->mem3_8; j; j = v12 )\n      {\n        v7 = *(_QWORD *)&j->mem4_0;\n        v9 = (mystruct_5 *)sub_1050E(a1, *(_QWORD *)&j->mem4_0);\n        v12 = *(mystruct_4 **)&j->mem4_8;\n        if ( *(_QWORD *)&v9->mem5_0 )\n        {\n          *(_QWORD *)&j->mem4_8 = *(_QWORD *)&v9->mem5_8;\n          *(_QWORD *)&v9->mem5_8 = j;\n        }\n        else\n        {\n          *(_QWORD *)&v9->mem5_0 = v7;\n          ++*(_QWORD *)&a1->mem1_24;\n          sub_1101C(a1, (mystruct_2 *)j);\n        }\n      }\n      v8 = *(_QWORD *)&i->mem3_0;\n      *(_QWORD *)&i->mem3_8 = 0LL;\n      if ( !a3 )\n      {\n        v10 = (mystruct_6 *)sub_1050E(a1, v8);\n        if ( *(_QWORD *)&v10->mem6_0 )\n        {\n          v11 = (mystruct_7 *)sub_10FCD(a1);\n          if ( !v11 )\n            return 0LL;\n          *(_QWORD *)&v11->mem7_0 = v8;\n          *(_QWORD *)&v11->mem7_8 = *(_QWORD *)&v10->mem6_8;\n          *(_QWORD *)&v10->mem6_8 = v11;\n        }\n        else\n        {\n          *(_QWORD *)&v10->mem6_0 = v8;\n          ++*(_QWORD *)&a1->mem1_24;\n        }\n        *(_QWORD *)&i->mem3_0 = 0LL;\n        --*(_QWORD *)&a2->mem2_24;\n      }\n    }\n  }\n  return 1LL;\n}\n",
  "0x113c3": "__int64 __fastcall sub_113C3(mystruct_1 *a1, unsigned __int64 a2)\n{\n  unsigned __int64 nmemb; // [rsp+10h] [rbp-70h]\n  void *v4; // [rsp+20h] [rbp-60h] BYREF\n  __int64 v5; // [rsp+28h] [rbp-58h]\n  unsigned __int64 v6; // [rsp+30h] [rbp-50h]\n  __int64 v7; // [rsp+38h] [rbp-48h]\n  __int64 v8; // [rsp+40h] [rbp-40h]\n  __int64 v9; // [rsp+48h] [rbp-38h]\n  __int64 v10; // [rsp+50h] [rbp-30h]\n  __int64 v11; // [rsp+58h] [rbp-28h]\n  __int64 v12; // [rsp+60h] [rbp-20h]\n  __int64 v13; // [rsp+68h] [rbp-18h]\n  unsigned __int64 v14; // [rsp+78h] [rbp-8h]\n\n  v14 = __readfsqword(0x28u);\n  nmemb = sub_10B05(a2, *(mystruct_1 **)&a1->mem1_40);\n  if ( !nmemb )\n    return 0LL;\n  if ( nmemb == *(_QWORD *)&a1->mem1_16 )\n    return 1LL;\n  v4 = calloc(nmemb, 0x10uLL);\n  if ( !v4 )\n    return 0LL;\n  v6 = nmemb;\n  v5 = (__int64)v4 + 16 * nmemb;\n  v7 = 0LL;\n  v8 = 0LL;\n  v9 = *(_QWORD *)&a1->mem1_40;\n  v10 = *(_QWORD *)&a1->mem1_48;\n  v11 = *(_QWORD *)&a1->mem1_56;\n  v12 = *(_QWORD *)&a1->mem1_64;\n  v13 = *(_QWORD *)&a1->mem1_72;\n  if ( (unsigned __int8)sub_111EF((mystruct_1 *)&v4, (mystruct_2 *)a1, 0) )\n  {\n    free(*(void **)&a1->mem1_0);\n    *(_QWORD *)&a1->mem1_0 = v4;\n    *(_QWORD *)&a1->mem1_8 = v5;\n    *(_QWORD *)&a1->mem1_16 = v6;\n    *(_QWORD *)&a1->mem1_24 = v7;\n    *(_QWORD *)&a1->mem1_72 = v13;\n    return 1LL;\n  }\n  else\n  {\n    *(_QWORD *)&a1->mem1_72 = v13;\n    if ( (unsigned __int8)sub_111EF(a1, (mystruct_2 *)&v4, 1) != 1\n      || (unsigned __int8)sub_111EF(a1, (mystruct_2 *)&v4, 0) != 1 )\n    {\n      abort();\n    }\n    free(v4);\n    return 0LL;\n  }\n}\n",
  "0x115ee": "__int64 __fastcall sub_115EE(mystruct_1 *a1, __int64 a2, _QWORD *a3)\n{\n  __int64 v4; // rax\n  float v5; // xmm0_4\n  __int64 v6; // rdx\n  __int64 v7; // rax\n  float v8; // xmm1_4\n  __int64 v9; // rdx\n  __int64 v10; // rax\n  float v11; // xmm0_4\n  __int64 v12; // rdx\n  __int64 v13; // rax\n  float v14; // xmm1_4\n  __int64 v15; // rdx\n  __int64 v16; // rax\n  float v17; // xmm0_4\n  __int64 v18; // rdx\n  float v19; // xmm0_4\n  __int64 v20; // rax\n  float v21; // xmm0_4\n  __int64 v22; // rdx\n  unsigned __int64 v23; // rax\n  mystruct_2 *v25; // [rsp+28h] [rbp-28h] BYREF\n  __int64 v26; // [rsp+30h] [rbp-20h]\n  mystruct_3 *v27; // [rsp+38h] [rbp-18h]\n  mystruct_4 *v28; // [rsp+40h] [rbp-10h]\n  unsigned __int64 v29; // [rsp+48h] [rbp-8h]\n\n  v29 = __readfsqword(0x28u);\n  if ( !a2 )\n    abort();\n  v26 = sub_11056(a1, a2, (mystruct_3 **)&v25, 0);\n  if ( v26 )\n  {\n    if ( a3 )\n      *a3 = v26;\n    return 0LL;\n  }\n  else\n  {\n    v4 = *(_QWORD *)&a1->mem1_24;\n    if ( v4 < 0 )\n    {\n      v6 = *(_QWORD *)&a1->mem1_24 & 1LL | ((unsigned __int64)v4 >> 1);\n      v5 = (float)(int)v6 + (float)(int)v6;\n    }\n    else\n    {\n      v5 = (float)(int)v4;\n    }\n    v7 = *(_QWORD *)&a1->mem1_16;\n    if ( v7 < 0 )\n    {\n      v9 = *(_QWORD *)&a1->mem1_16 & 1LL | ((unsigned __int64)v7 >> 1);\n      v8 = (float)(int)v9 + (float)(int)v9;\n    }\n    else\n    {\n      v8 = (float)(int)v7;\n    }\n    if ( v5 > (float)(v8 * *(float *)(*(_QWORD *)&a1->mem1_40 + 8LL)) )\n    {\n      sub_109F8(a1);\n      v10 = *(_QWORD *)&a1->mem1_24;\n      if ( v10 < 0 )\n      {\n        v12 = *(_QWORD *)&a1->mem1_24 & 1LL | ((unsigned __int64)v10 >> 1);\n        v11 = (float)(int)v12 + (float)(int)v12;\n      }\n      else\n      {\n        v11 = (float)(int)v10;\n      }\n      v13 = *(_QWORD *)&a1->mem1_16;\n      if ( v13 < 0 )\n      {\n        v15 = *(_QWORD *)&a1->mem1_16 & 1LL | ((unsigned __int64)v13 >> 1);\n        v14 = (float)(int)v15 + (float)(int)v15;\n      }\n      else\n      {\n        v14 = (float)(int)v13;\n      }\n      if ( v11 > (float)(v14 * *(float *)(*(_QWORD *)&a1->mem1_40 + 8LL)) )\n      {\n        v27 = *(mystruct_3 **)&a1->mem1_40;\n        if ( v27->mem3_16 )\n        {\n          v16 = *(_QWORD *)&a1->mem1_16;\n          if ( v16 < 0 )\n          {\n            v18 = *(_QWORD *)&a1->mem1_16 & 1LL | ((unsigned __int64)v16 >> 1);\n            v17 = (float)(int)v18 + (float)(int)v18;\n          }\n          else\n          {\n            v17 = (float)(int)v16;\n          }\n          v19 = v17 * *(float *)&v27->mem3_12;\n        }\n        else\n        {\n          v20 = *(_QWORD *)&a1->mem1_16;\n          if ( v20 < 0 )\n          {\n            v22 = *(_QWORD *)&a1->mem1_16 & 1LL | ((unsigned __int64)v20 >> 1);\n            v21 = (float)(int)v22 + (float)(int)v22;\n          }\n          else\n          {\n            v21 = (float)(int)v20;\n          }\n          v19 = *(float *)&v27->mem3_8 * (float)(*(float *)&v27->mem3_12 * v21);\n        }\n        if ( v19 >= 1.8446744e19 )\n          return 0xFFFFFFFFLL;\n        if ( v19 >= 9.223372e18 )\n          v23 = (unsigned int)(int)(float)(v19 - 9.223372e18) ^ 0x8000000000000000LL;\n        else\n          v23 = (unsigned int)(int)v19;\n        if ( (unsigned __int8)sub_113C3(a1, v23) != 1 )\n          return 0xFFFFFFFFLL;\n        if ( sub_11056(a1, a2, (mystruct_3 **)&v25, 0) )\n          abort();\n      }\n    }\n    if ( *(_QWORD *)&v25->mem2_0 )\n    {\n      v28 = (mystruct_4 *)sub_10FCD(a1);\n      if ( v28 )\n      {\n        *(_QWORD *)&v28->mem4_0 = a2;\n        *(_QWORD *)&v28->mem4_8 = *(_QWORD *)&v25->mem2_8;\n        *(_QWORD *)&v25->mem2_8 = v28;\n        ++*(_QWORD *)&a1->mem1_32;\n        return 1LL;\n      }\n      else\n      {\n        return 0xFFFFFFFFLL;\n      }\n    }\n    else\n    {\n      *(_QWORD *)&v25->mem2_0 = a2;\n      ++*(_QWORD *)&a1->mem1_32;\n      ++*(_QWORD *)&a1->mem1_24;\n      return 1LL;\n    }\n  }\n}\n",
  "0x119cf": "__int64 __fastcall sub_119CF(mystruct_1 *a1, __int64 a2)\n{\n  __int64 v3; // rax\n  float v4; // xmm0_4\n  __int64 v5; // rdx\n  __int64 v6; // rax\n  float v7; // xmm1_4\n  __int64 v8; // rdx\n  __int64 v9; // rax\n  float v10; // xmm0_4\n  __int64 v11; // rdx\n  __int64 v12; // rax\n  float v13; // xmm1_4\n  __int64 v14; // rdx\n  __int64 v15; // rax\n  float v16; // xmm0_4\n  __int64 v17; // rdx\n  float v18; // xmm0_4\n  __int64 v19; // rax\n  __int64 v20; // rax\n  float v21; // xmm0_4\n  __int64 v22; // rdx\n  float v23; // xmm0_4\n  mystruct_3 *v24; // [rsp+18h] [rbp-38h] BYREF\n  mystruct_2 *ptr; // [rsp+20h] [rbp-30h]\n  __int64 v26; // [rsp+28h] [rbp-28h]\n  mystruct_3 *v27; // [rsp+30h] [rbp-20h]\n  __int64 v28; // [rsp+38h] [rbp-18h]\n  mystruct_2 *v29; // [rsp+40h] [rbp-10h]\n  unsigned __int64 v30; // [rsp+48h] [rbp-8h]\n\n  v30 = __readfsqword(0x28u);\n  v26 = sub_11056(a1, a2, &v24, 1);\n  if ( !v26 )\n    return 0LL;\n  --*(_QWORD *)&a1->mem1_32;\n  if ( !*(_QWORD *)&v24->mem3_0 )\n  {\n    v3 = --*(_QWORD *)&a1->mem1_24;\n    if ( v3 < 0 )\n    {\n      v5 = *(_QWORD *)&a1->mem1_24 & 1LL | ((unsigned __int64)v3 >> 1);\n      v4 = (float)(int)v5 + (float)(int)v5;\n    }\n    else\n    {\n      v4 = (float)(int)v3;\n    }\n    v6 = *(_QWORD *)&a1->mem1_16;\n    if ( v6 < 0 )\n    {\n      v8 = *(_QWORD *)&a1->mem1_16 & 1LL | ((unsigned __int64)v6 >> 1);\n      v7 = (float)(int)v8 + (float)(int)v8;\n    }\n    else\n    {\n      v7 = (float)(int)v6;\n    }\n    if ( (float)(v7 * **(float **)&a1->mem1_40) > v4 )\n    {\n      sub_109F8(a1);\n      v9 = *(_QWORD *)&a1->mem1_24;\n      if ( v9 < 0 )\n      {\n        v11 = *(_QWORD *)&a1->mem1_24 & 1LL | ((unsigned __int64)v9 >> 1);\n        v10 = (float)(int)v11 + (float)(int)v11;\n      }\n      else\n      {\n        v10 = (float)(int)v9;\n      }\n      v12 = *(_QWORD *)&a1->mem1_16;\n      if ( v12 < 0 )\n      {\n        v14 = *(_QWORD *)&a1->mem1_16 & 1LL | ((unsigned __int64)v12 >> 1);\n        v13 = (float)(int)v14 + (float)(int)v14;\n      }\n      else\n      {\n        v13 = (float)(int)v12;\n      }\n      if ( (float)(v13 * **(float **)&a1->mem1_40) > v10 )\n      {\n        v27 = *(mystruct_3 **)&a1->mem1_40;\n        if ( v27->mem3_16 )\n        {\n          v15 = *(_QWORD *)&a1->mem1_16;\n          if ( v15 < 0 )\n          {\n            v17 = *(_QWORD *)&a1->mem1_16 & 1LL | ((unsigned __int64)v15 >> 1);\n            v16 = (float)(int)v17 + (float)(int)v17;\n          }\n          else\n          {\n            v16 = (float)(int)v15;\n          }\n          v18 = v16 * *(float *)&v27->mem3_4;\n          if ( v18 >= 9.223372e18 )\n            v19 = (unsigned int)(int)(float)(v18 - 9.223372e18) ^ 0x8000000000000000LL;\n          else\n            v19 = (unsigned int)(int)v18;\n        }\n        else\n        {\n          v20 = *(_QWORD *)&a1->mem1_16;\n          if ( v20 < 0 )\n          {\n            v22 = *(_QWORD *)&a1->mem1_16 & 1LL | ((unsigned __int64)v20 >> 1);\n            v21 = (float)(int)v22 + (float)(int)v22;\n          }\n          else\n          {\n            v21 = (float)(int)v20;\n          }\n          v23 = *(float *)&v27->mem3_8 * (float)(*(float *)&v27->mem3_4 * v21);\n          if ( v23 >= 9.223372e18 )\n            v19 = (unsigned int)(int)(float)(v23 - 9.223372e18) ^ 0x8000000000000000LL;\n          else\n            v19 = (unsigned int)(int)v23;\n        }\n        v28 = v19;\n        if ( (unsigned __int8)sub_113C3(a1, v19) != 1 )\n        {\n          for ( ptr = *(mystruct_2 **)&a1->mem1_72; ptr; ptr = v29 )\n          {\n            v29 = *(mystruct_2 **)&ptr->mem2_8;\n            free(ptr);\n          }\n          *(_QWORD *)&a1->mem1_72 = 0LL;\n        }\n      }\n    }\n  }\n  return v26;\n}\n",
  "0x11cd5": "unsigned __int64 __fastcall sub_11CD5(mystruct_1 *a1, unsigned __int64 a2)\n{\n  return (sub_17FBA(*(_BYTE **)&a1->mem1_0, a2) ^ *(_QWORD *)&a1->mem1_8) % a2;\n}\n",
  "0x11d25": "unsigned __int64 __fastcall sub_11D25(mystruct_1 *a1, unsigned __int64 a2)\n{\n  return *(_QWORD *)&a1->mem1_8 % a2;\n}\n",
  "0x11d53": "_BOOL8 __fastcall sub_11D53(mystruct_1 *a1, mystruct_2 *a2)\n{\n  return *(_QWORD *)&a1->mem1_8 == *(_QWORD *)&a2->mem2_8\n      && *(_QWORD *)&a1->mem1_16 == *(_QWORD *)&a2->mem2_16\n      && (unsigned __int8)sub_144BD(*(_QWORD *)&a1->mem1_0, *(_QWORD *)&a2->mem2_0);\n}\n",
  "0x11dcf": "_BOOL8 __fastcall sub_11DCF(mystruct_1 *a1, mystruct_2 *a2)\n{\n  return *(_QWORD *)&a1->mem1_8 == *(_QWORD *)&a2->mem2_8\n      && *(_QWORD *)&a1->mem1_16 == *(_QWORD *)&a2->mem2_16\n      && !strcmp(*(const char **)&a1->mem1_0, *(const char **)&a2->mem2_0);\n}\n",
  "0x12246": "__int64 __fastcall sub_12246(mystruct_1 *a1, int a2)\n{\n  mystruct_1 *v3; // [rsp+4h] [rbp-18h]\n  unsigned int v4; // [rsp+18h] [rbp-4h]\n\n  v3 = a1;\n  if ( !a1 )\n    v3 = (mystruct_1 *)&qword_24620;\n  v4 = *(_DWORD *)&v3->mem1_4;\n  *(_DWORD *)&v3->mem1_4 = a2;\n  return v4;\n}\n",
  "0x12280": "mystruct_1 *__fastcall sub_12280(mystruct_1 *a1, __int64 a2, __int64 a3)\n{\n  mystruct_1 *result; // rax\n  mystruct_1 *v4; // [rsp+18h] [rbp-8h]\n\n  v4 = a1;\n  if ( !a1 )\n    v4 = (mystruct_1 *)&qword_24620;\n  *(_DWORD *)&v4->mem1_0 = 10;\n  if ( !a2 || !a3 )\n    abort();\n  *(_QWORD *)&v4->mem1_40 = a2;\n  result = v4;\n  *(_QWORD *)&v4->mem1_48 = a3;\n  return result;\n}\n",
  "0x122e2": "mystruct_1 *__fastcall sub_122E2(mystruct_1 *a1, unsigned int a2)\n{\n  if ( a2 == 10 )\n    abort();\n  *(_QWORD *)&a1->mem1_0 = a2;\n  *(_QWORD *)&a1->mem1_8 = 0LL;\n  *(_QWORD *)&a1->mem1_16 = 0LL;\n  *(_QWORD *)&a1->mem1_24 = 0LL;\n  *(_QWORD *)&a1->mem1_32 = 0LL;\n  *(_QWORD *)&a1->mem1_40 = 0LL;\n  *(_QWORD *)&a1->mem1_48 = 0LL;\n  return a1;\n}\n",
  "0x1246c": "unsigned __int64 __fastcall sub_1246C(\n        __int64 a1,\n        unsigned __int64 a2,\n        mystruct_1 *a3,\n        size_t a4,\n        int a5,\n        int a6,\n        __int64 a7,\n        char *a8,\n        char *a9)\n{\n  size_t v9; // rbx\n  size_t v10; // rax\n  __int64 v11; // rax\n  unsigned int v12; // eax\n  bool v13; // al\n  unsigned int v14; // eax\n  char v24; // [rsp+48h] [rbp-78h]\n  bool v25; // [rsp+49h] [rbp-77h]\n  char v26; // [rsp+4Ah] [rbp-76h]\n  char v27; // [rsp+4Bh] [rbp-75h]\n  char v28; // [rsp+4Ch] [rbp-74h]\n  unsigned __int8 v29; // [rsp+4Dh] [rbp-73h]\n  char v30; // [rsp+4Eh] [rbp-72h]\n  char v31; // [rsp+4Fh] [rbp-71h]\n  char v32; // [rsp+50h] [rbp-70h]\n  char v33; // [rsp+51h] [rbp-6Fh]\n  bool v34; // [rsp+52h] [rbp-6Eh]\n  bool v35; // [rsp+53h] [rbp-6Dh]\n  wint_t wc; // [rsp+54h] [rbp-6Ch] BYREF\n  __int64 i; // [rsp+58h] [rbp-68h]\n  unsigned __int64 v38; // [rsp+60h] [rbp-60h]\n  unsigned __int64 v39; // [rsp+68h] [rbp-58h]\n  char *s; // [rsp+70h] [rbp-50h]\n  size_t n; // [rsp+78h] [rbp-48h]\n  unsigned __int64 v42; // [rsp+80h] [rbp-40h]\n  unsigned __int64 j; // [rsp+88h] [rbp-38h]\n  size_t v44; // [rsp+90h] [rbp-30h]\n  unsigned __int64 v45; // [rsp+98h] [rbp-28h]\n  mbstate_t ps; // [rsp+A0h] [rbp-20h] BYREF\n  unsigned __int64 v47; // [rsp+A8h] [rbp-18h]\n\n  v47 = __readfsqword(0x28u);\n  v38 = 0LL;\n  v39 = 0LL;\n  s = 0LL;\n  n = 0LL;\n  v24 = 0;\n  v35 = __ctype_get_mb_cur_max() == 1;\n  v25 = (a6 & 2) != 0;\n  v26 = 0;\n  v27 = 0;\n  v28 = 1;\n  while ( 2 )\n  {\n    switch ( a5 )\n    {\n      case 0:\n        v25 = 0;\n        break;\n      case 1:\n        goto LABEL_20;\n      case 2:\n        goto LABEL_23;\n      case 3:\n        v24 = 1;\nLABEL_20:\n        v25 = 1;\n        goto LABEL_21;\n      case 4:\nLABEL_21:\n        if ( !v25 )\n          v24 = 1;\nLABEL_23:\n        a5 = 2;\n        if ( !v25 )\n        {\n          if ( v38 < a2 )\n            *(_BYTE *)(a1 + v38) = 39;\n          ++v38;\n        }\n        s = \"'\";\n        n = 1LL;\n        break;\n      case 5:\n        goto LABEL_4;\n      case 6:\n        a5 = 5;\n        v25 = 1;\nLABEL_4:\n        if ( !v25 )\n        {\n          if ( v38 < a2 )\n            *(_BYTE *)(a1 + v38) = 34;\n          ++v38;\n        }\n        v24 = 1;\n        s = (char *)&unk_1D9C5;\n        n = 1LL;\n        break;\n      case 7:\n        v24 = 1;\n        v25 = 0;\n        break;\n      case 8:\n      case 9:\n      case 10:\n        if ( a5 != 10 )\n        {\n          a8 = sub_123A7(\"`\", a5);\n          a9 = sub_123A7(\"'\", a5);\n        }\n        if ( !v25 )\n        {\n          for ( s = a8; *s; ++s )\n          {\n            if ( v38 < a2 )\n              *(_BYTE *)(v38 + a1) = *s;\n            ++v38;\n          }\n        }\n        v24 = 1;\n        s = a9;\n        n = strlen(a9);\n        break;\n      default:\n        abort();\n    }\n    for ( i = 0LL; a4 == -1LL ? *(&a3->mem1_0 + i) != 0 : i != a4; ++i )\n    {\n      v31 = 0;\n      v32 = 0;\n      v33 = 0;\n      if ( v24 && a5 != 2 && n )\n      {\n        v9 = i + n;\n        if ( a4 == -1LL && n > 1 )\n        {\n          v10 = strlen(&a3->mem1_0);\n          a4 = v10;\n        }\n        else\n        {\n          v10 = a4;\n        }\n        if ( v10 >= v9 && !memcmp(&a3->mem1_0 + i, s, n) )\n        {\n          if ( v25 )\n            goto LABEL_262;\n          v31 = 1;\n        }\n      }\n      v29 = *(&a3->mem1_0 + i);\n      if ( v29 == 126 )\n        goto LABEL_126;\n      if ( v29 > 0x7Eu )\n        goto LABEL_144;\n      if ( v29 == 125 )\n      {\nLABEL_122:\n        if ( a4 == -1LL )\n          v13 = a3->mem1_1 != 0;\n        else\n          v13 = a4 != 1;\n        if ( v13 )\n          goto LABEL_206;\nLABEL_126:\n        if ( i )\n          goto LABEL_206;\nLABEL_127:\n        v33 = 1;\n        goto LABEL_128;\n      }\n      if ( v29 > 0x7Du )\n        goto LABEL_144;\n      if ( v29 == 124 )\n        goto LABEL_128;\n      if ( v29 == 123 )\n        goto LABEL_122;\n      if ( v29 > 0x3Fu )\n      {\n        if ( v29 < 0x41u )\n        {\nLABEL_144:\n          if ( v35 )\n          {\n            v42 = 1LL;\n            v34 = ((*__ctype_b_loc())[v29] & 0x4000) != 0;\n          }\n          else\n          {\n            memset(&ps, 0, sizeof(ps));\n            v42 = 0LL;\n            v34 = 1;\n            if ( a4 == -1LL )\n              a4 = strlen(&a3->mem1_0);\n            do\n            {\n              v44 = sub_178C7((wchar_t *)&wc, (const char *)&a3->mem1_0 + v42 + i, a4 - (v42 + i), &ps);\n              if ( !v44 )\n                break;\n              if ( v44 == -1LL )\n              {\n                v34 = 0;\n                break;\n              }\n              if ( v44 == -2LL )\n              {\n                v34 = 0;\n                while ( a4 > i + v42 && *(&a3->mem1_0 + v42 + i) )\n                  ++v42;\n                break;\n              }\n              if ( v25 && a5 == 2 )\n              {\n                for ( j = 1LL; j < v44; ++j )\n                {\n                  v14 = *(&a3->mem1_0 + j + v42 + i) - 91;\n                  if ( v14 <= 0x21 && ((0x20000002BuLL >> v14) & 1) != 0 )\n                    goto LABEL_262;\n                }\n              }\n              if ( !iswprint(wc) )\n                v34 = 0;\n              v42 += v44;\n            }\n            while ( !mbsinit(&ps) );\n          }\n          v33 = v34;\n          if ( v42 > 1 || v24 && !v34 )\n          {\n            v45 = i + v42;\n            while ( 1 )\n            {\n              if ( v24 && !v34 )\n              {\n                if ( v25 )\n                  goto LABEL_262;\n                v32 = 1;\n                if ( a5 == 2 && v26 != 1 )\n                {\n                  if ( v38 < a2 )\n                    *(_BYTE *)(a1 + v38) = 39;\n                  if ( ++v38 < a2 )\n                    *(_BYTE *)(a1 + v38) = 36;\n                  if ( ++v38 < a2 )\n                    *(_BYTE *)(a1 + v38) = 39;\n                  ++v38;\n                  v26 = 1;\n                }\n                if ( v38 < a2 )\n                  *(_BYTE *)(a1 + v38) = 92;\n                if ( ++v38 < a2 )\n                  *(_BYTE *)(a1 + v38) = (v29 >> 6) + 48;\n                if ( ++v38 < a2 )\n                  *(_BYTE *)(a1 + v38) = ((v29 >> 3) & 7) + 48;\n                ++v38;\n                v29 = (v29 & 7) + 48;\n              }\n              else if ( v31 )\n              {\n                if ( v38 < a2 )\n                  *(_BYTE *)(a1 + v38) = 92;\n                ++v38;\n                v31 = 0;\n              }\n              if ( v45 <= i + 1 )\n                goto LABEL_225;\n              if ( v26 && v32 != 1 )\n              {\n                if ( v38 < a2 )\n                  *(_BYTE *)(a1 + v38) = 39;\n                if ( ++v38 < a2 )\n                  *(_BYTE *)(a1 + v38) = 39;\n                ++v38;\n                v26 = 0;\n              }\n              if ( v38 < a2 )\n                *(_BYTE *)(v38 + a1) = v29;\n              ++v38;\n              ++i;\n              v29 = *(&a3->mem1_0 + i);\n            }\n          }\nLABEL_206:\n          if ( (v24 == 1 && a5 != 2 || v25) && a7 && ((*(_DWORD *)(4LL * (v29 >> 5) + a7) >> (v29 & 0x1F)) & 1) != 0\n            || v31 == 1 )\n          {\nLABEL_212:\n            if ( v25 )\n              goto LABEL_262;\n            v32 = 1;\n            if ( a5 == 2 && v26 != 1 )\n            {\n              if ( v38 < a2 )\n                *(_BYTE *)(a1 + v38) = 39;\n              if ( ++v38 < a2 )\n                *(_BYTE *)(a1 + v38) = 36;\n              if ( ++v38 < a2 )\n                *(_BYTE *)(a1 + v38) = 39;\n              ++v38;\n              v26 = 1;\n            }\n            if ( v38 < a2 )\n              *(_BYTE *)(a1 + v38) = 92;\n            ++v38;\n            goto LABEL_225;\n          }\n          goto LABEL_225;\n        }\n        v11 = 1LL << (v29 - 65);\n        if ( (v11 & 0x3FFFFFF53FFFFFFLL) != 0 )\n        {\nLABEL_143:\n          v33 = 1;\n          goto LABEL_206;\n        }\n        if ( (v11 & 0xA4000000) == 0 )\n        {\n          if ( (v11 & 0x8000000) == 0 )\n            goto LABEL_144;\n          v30 = *(&a3->mem1_0 + i);\n          if ( a5 == 2 )\n          {\n            if ( v25 )\n              goto LABEL_262;\n            goto LABEL_225;\n          }\n          if ( !v24 || !v25 || !n )\n          {\nLABEL_118:\n            if ( a5 == 2 && v25 )\n              goto LABEL_262;\nLABEL_120:\n            if ( !v24 )\n              goto LABEL_206;\n            v29 = v30;\n            goto LABEL_212;\n          }\nLABEL_225:\n          if ( v26 && v32 != 1 )\n          {\n            if ( v38 < a2 )\n              *(_BYTE *)(a1 + v38) = 39;\n            if ( ++v38 < a2 )\n              *(_BYTE *)(a1 + v38) = 39;\n            ++v38;\n            v26 = 0;\n          }\n          if ( v38 < a2 )\n            *(_BYTE *)(v38 + a1) = v29;\n          ++v38;\n          if ( v33 != 1 )\n            v28 = 0;\n          continue;\n        }\nLABEL_128:\n        if ( a5 == 2 && v25 )\n          goto LABEL_262;\n        goto LABEL_206;\n      }\n      switch ( v29 )\n      {\n        case 0u:\n          if ( v24 )\n          {\n            if ( v25 )\n              goto LABEL_262;\n            v32 = 1;\n            if ( a5 == 2 && v26 != 1 )\n            {\n              if ( v38 < a2 )\n                *(_BYTE *)(a1 + v38) = 39;\n              if ( ++v38 < a2 )\n                *(_BYTE *)(a1 + v38) = 36;\n              if ( ++v38 < a2 )\n                *(_BYTE *)(a1 + v38) = 39;\n              ++v38;\n              v26 = 1;\n            }\n            if ( v38 < a2 )\n              *(_BYTE *)(a1 + v38) = 92;\n            ++v38;\n            if ( a5 != 2 && a4 > i + 1 && *(&a3->mem1_1 + i) > 47 && *(&a3->mem1_1 + i) <= 57 )\n            {\n              if ( v38 < a2 )\n                *(_BYTE *)(a1 + v38) = 48;\n              if ( ++v38 < a2 )\n                *(_BYTE *)(a1 + v38) = 48;\n              ++v38;\n            }\n            v29 = 48;\n            goto LABEL_206;\n          }\n          if ( (a6 & 1) == 0 )\n            goto LABEL_206;\n          break;\n        case 7u:\n          v30 = 97;\n          goto LABEL_120;\n        case 8u:\n          v30 = 98;\n          goto LABEL_120;\n        case 9u:\n          v30 = 116;\n          goto LABEL_118;\n        case 0xAu:\n          v30 = 110;\n          goto LABEL_118;\n        case 0xBu:\n          v30 = 118;\n          goto LABEL_120;\n        case 0xCu:\n          v30 = 102;\n          goto LABEL_120;\n        case 0xDu:\n          v30 = 114;\n          goto LABEL_118;\n        case 0x20u:\n          goto LABEL_127;\n        case 0x21u:\n        case 0x22u:\n        case 0x24u:\n        case 0x26u:\n        case 0x28u:\n        case 0x29u:\n        case 0x2Au:\n        case 0x3Bu:\n        case 0x3Cu:\n        case 0x3Du:\n        case 0x3Eu:\n          goto LABEL_128;\n        case 0x23u:\n          goto LABEL_126;\n        case 0x25u:\n        case 0x2Bu:\n        case 0x2Cu:\n        case 0x2Du:\n        case 0x2Eu:\n        case 0x2Fu:\n        case 0x30u:\n        case 0x31u:\n        case 0x32u:\n        case 0x33u:\n        case 0x34u:\n        case 0x35u:\n        case 0x36u:\n        case 0x37u:\n        case 0x38u:\n        case 0x39u:\n        case 0x3Au:\n          goto LABEL_143;\n        case 0x27u:\n          v27 = 1;\n          v33 = 1;\n          if ( a5 != 2 )\n            goto LABEL_206;\n          if ( v25 )\n            goto LABEL_262;\n          if ( a2 && !v39 )\n          {\n            v39 = a2;\n            a2 = 0LL;\n          }\n          if ( v38 < a2 )\n            *(_BYTE *)(a1 + v38) = 39;\n          if ( ++v38 < a2 )\n            *(_BYTE *)(a1 + v38) = 92;\n          if ( ++v38 < a2 )\n            *(_BYTE *)(a1 + v38) = 39;\n          ++v38;\n          v26 = 0;\n          goto LABEL_206;\n        case 0x3Fu:\n          if ( a5 == 2 )\n          {\n            if ( v25 )\n              goto LABEL_262;\n          }\n          else if ( a5 == 5 && (a6 & 4) != 0 && a4 > i + 2 && *(&a3->mem1_1 + i) == 63 )\n          {\n            v12 = *(&a3->mem1_2 + i);\n            if ( v12 <= 0x3E && ((0x7000A38200000000uLL >> v12) & 1) != 0 )\n            {\n              if ( v25 )\n                goto LABEL_262;\n              v29 = *(&a3->mem1_2 + i);\n              i += 2LL;\n              if ( v38 < a2 )\n                *(_BYTE *)(a1 + v38) = 63;\n              if ( ++v38 < a2 )\n                *(_BYTE *)(a1 + v38) = 34;\n              if ( ++v38 < a2 )\n                *(_BYTE *)(a1 + v38) = 34;\n              if ( ++v38 < a2 )\n                *(_BYTE *)(a1 + v38) = 63;\n              ++v38;\n            }\n          }\n          goto LABEL_206;\n        default:\n          goto LABEL_144;\n      }\n    }\n    if ( !v38 && a5 == 2 && v25 )\n    {\nLABEL_262:\n      if ( a5 == 2 && v24 )\n        a5 = 4;\n      return sub_1246C(a1, a2, (__int64)a3, a4, a5, a6 & 0xFFFFFFFD, 0LL, a8, a9);\n    }\n    if ( a5 == 2 && !v25 && v27 )\n    {\n      if ( v28 )\n        return sub_1246C(a1, v39, (__int64)a3, a4, 5, a6, a7, a8, a9);\n      if ( !a2 && v39 )\n      {\n        a2 = v39;\n        v38 = 0LL;\n        continue;\n      }\n    }\n    break;\n  }\n  if ( s && !v25 )\n  {\n    while ( *s )\n    {\n      if ( v38 < a2 )\n        *(_BYTE *)(v38 + a1) = *s;\n      ++v38;\n      ++s;\n    }\n  }\n  if ( v38 < a2 )\n    *(_BYTE *)(a1 + v38) = 0;\n  return v38;\n}\n",
  "0x135ff": "__int64 __fastcall sub_135FF(mystruct_1 *a1, size_t a2, _QWORD *a3, __int64 *a4)\n{\n  __int64 *v4; // rax\n  int v7; // [rsp+20h] [rbp-20h]\n  int v8; // [rsp+24h] [rbp-1Ch]\n  mystruct_1 *v9; // [rsp+28h] [rbp-18h]\n  unsigned __int64 v10; // [rsp+30h] [rbp-10h]\n  __int64 v11; // [rsp+38h] [rbp-8h]\n\n  if ( a4 )\n    v4 = a4;\n  else\n    v4 = &qword_24620;\n  v9 = (mystruct_1 *)v4;\n  v7 = *__errno_location();\n  v8 = *(_DWORD *)&v9->mem1_4 | (a3 == 0LL);\n  v10 = sub_1246C(\n          0LL,\n          0LL,\n          a1,\n          a2,\n          *(_DWORD *)&v9->mem1_0,\n          v8,\n          (__int64)&v9->mem1_8,\n          *(char **)&v9->mem1_40,\n          *(char **)&v9->mem1_48)\n      + 1;\n  v11 = sub_17440(v10);\n  sub_1246C(\n    v11,\n    v10,\n    a1,\n    a2,\n    *(_DWORD *)&v9->mem1_0,\n    v8,\n    (__int64)&v9->mem1_8,\n    *(char **)&v9->mem1_40,\n    *(char **)&v9->mem1_48);\n  *__errno_location() = v7;\n  if ( a3 )\n    *a3 = v10 - 1;\n  return v11;\n}\n",
  "0x1372b": "__int64 **sub_1372B()\n{\n  __int64 **result; // rax\n  int i; // [rsp+4h] [rbp-Ch]\n  mystruct_1 *ptr; // [rsp+8h] [rbp-8h]\n\n  ptr = (mystruct_1 *)off_240B0;\n  for ( i = 1; i < dword_24040; ++i )\n    free(*((void **)&ptr->mem1_8 + 2 * i));\n  if ( *(_UNKNOWN **)&ptr->mem1_8 != &unk_24660 )\n  {\n    free(*(void **)&ptr->mem1_8);\n    off_240A0 = &qword_100;\n    off_240A8 = &unk_24660;\n  }\n  result = &off_240A0;\n  if ( ptr != (mystruct_1 *)&off_240A0 )\n  {\n    free(ptr);\n    result = &off_240A0;\n    off_240B0 = &off_240A0;\n  }\n  dword_24040 = 1;\n  return result;\n}\n",
  "0x137ea": "__int64 *__fastcall sub_137EA(__int64 a1, mystruct_1 *a2, size_t a3, mystruct_1 *a4)\n{\n  __int64 **v4; // rax\n  void *v5; // rdx\n  bool v9; // [rsp+23h] [rbp-2Dh]\n  int v10; // [rsp+24h] [rbp-2Ch]\n  int v11; // [rsp+2Ch] [rbp-24h]\n  mystruct_2 *v12; // [rsp+30h] [rbp-20h]\n  void *ptr; // [rsp+38h] [rbp-18h]\n  unsigned __int64 v14; // [rsp+40h] [rbp-10h]\n  unsigned __int64 v15; // [rsp+40h] [rbp-10h]\n  unsigned __int64 v16; // [rsp+48h] [rbp-8h]\n\n  v10 = *__errno_location();\n  v12 = (mystruct_2 *)off_240B0;\n  if ( (int)a1 < 0 )\n    abort();\n  if ( (int)a1 >= dword_24040 )\n  {\n    v9 = off_240B0 == &off_240A0;\n    if ( (_DWORD)a1 == 0x7FFFFFFF )\n      sub_1761B();\n    if ( off_240B0 == &off_240A0 )\n      v4 = 0LL;\n    else\n      v4 = off_240B0;\n    v12 = (mystruct_2 *)sub_17497(v4, 16LL * ((int)a1 + 1));\n    off_240B0 = (__int64 **)v12;\n    if ( v9 )\n    {\n      v5 = off_240A8;\n      *(_QWORD *)&v12->mem2_0 = off_240A0;\n      *(_QWORD *)&v12->mem2_8 = v5;\n    }\n    memset((char *)v12 + 16 * dword_24040, 0, 16LL * ((int)a1 + 1 - dword_24040));\n    dword_24040 = a1 + 1;\n  }\n  v14 = *((_QWORD *)&v12->mem2_0 + 2 * (int)a1);\n  ptr = (void *)*((_QWORD *)&v12->mem2_8 + 2 * (int)a1);\n  v11 = *(_DWORD *)&a4->mem1_4 | 1;\n  v16 = sub_1246C(\n          (__int64)ptr,\n          v14,\n          a2,\n          a3,\n          *(_DWORD *)&a4->mem1_0,\n          v11,\n          (__int64)&a4->mem1_8,\n          *(char **)&a4->mem1_40,\n          *(char **)&a4->mem1_48);\n  if ( v14 <= v16 )\n  {\n    v15 = v16 + 1;\n    *((_QWORD *)&v12->mem2_0 + 2 * (int)a1) = v16 + 1;\n    if ( ptr != &unk_24660 )\n      free(ptr);\n    ptr = (void *)sub_17440(v15);\n    *((_QWORD *)&v12->mem2_8 + 2 * (int)a1) = ptr;\n    sub_1246C(\n      (__int64)ptr,\n      v15,\n      a2,\n      a3,\n      *(_DWORD *)&a4->mem1_0,\n      v11,\n      (__int64)&a4->mem1_8,\n      *(char **)&a4->mem1_40,\n      *(char **)&a4->mem1_48);\n  }\n  *__errno_location() = v10;\n  return (__int64 *)ptr;\n}\n",
  "0x14779": "__int64 __fastcall sub_14779(mystruct_1 *a1, mystruct_2 *a2)\n{\n  if ( *(_QWORD *)&a1->mem1_8 < *(_QWORD *)&a2->mem2_8 )\n    return 0xFFFFFFFFLL;\n  else\n    return *(_QWORD *)&a1->mem1_8 > *(_QWORD *)&a2->mem2_8;\n}\n",
  "0x147d0": "void *__fastcall sub_147D0(DIR *a1, __int64 a2)\n{\n  __int64 v3; // rdx\n  void **v4; // rbx\n  char *v5; // rax\n  int v6; // [rsp+1Ch] [rbp-84h]\n  __int64 v7; // [rsp+20h] [rbp-80h] BYREF\n  void *v8; // [rsp+28h] [rbp-78h]\n  __int64 v9; // [rsp+30h] [rbp-70h]\n  void *ptr; // [rsp+38h] [rbp-68h]\n  __int64 v11; // [rsp+40h] [rbp-60h]\n  size_t nmemb; // [rsp+48h] [rbp-58h]\n  unsigned __int64 v13; // [rsp+50h] [rbp-50h]\n  size_t i; // [rsp+58h] [rbp-48h]\n  __compar_fn_t compar; // [rsp+60h] [rbp-40h]\n  struct dirent *v16; // [rsp+68h] [rbp-38h]\n  mystruct_1 *src; // [rsp+70h] [rbp-30h]\n  size_t n; // [rsp+78h] [rbp-28h]\n  char *dest; // [rsp+80h] [rbp-20h]\n  unsigned __int64 v20; // [rsp+88h] [rbp-18h]\n\n  v20 = __readfsqword(0x28u);\n  v8 = 0LL;\n  v9 = 0LL;\n  ptr = 0LL;\n  v11 = 0LL;\n  nmemb = 0LL;\n  v13 = 0LL;\n  compar = (__compar_fn_t)qword_23A20[(unsigned int)a2];\n  if ( !a1 )\n    return 0LL;\n  while ( 1 )\n  {\n    *__errno_location() = 0;\n    v16 = readdir(a1);\n    if ( !v16 )\n      break;\n    src = (mystruct_1 *)v16->d_name;\n    if ( v16->d_name[0] == 46 )\n    {\n      if ( src->mem1_1 == 46 )\n        v3 = 2LL;\n      else\n        v3 = 1LL;\n    }\n    else\n    {\n      v3 = 0LL;\n    }\n    if ( *(&src->mem1_0 + v3) )\n    {\n      n = strlen(v16->d_name) + 1;\n      if ( compar )\n      {\n        if ( v11 == nmemb )\n        {\n          v7 = v11;\n          a2 = (__int64)&v7;\n          ptr = (void *)sub_17362((__int64)ptr, (unsigned __int64 *)&v7, 0x10uLL);\n          v11 = v7;\n        }\n        v4 = (void **)((char *)ptr + 16 * nmemb);\n        *v4 = sub_175EA(&src->mem1_0);\n        *((_QWORD *)ptr + 2 * nmemb++ + 1) = v16->d_ino;\n      }\n      else\n      {\n        if ( n >= v9 - v13 )\n        {\n          v7 = v13 + n;\n          if ( v13 > v13 + n )\n            sub_1761B();\n          v8 = (void *)sub_17362((__int64)v8, (unsigned __int64 *)&v7, 1uLL);\n          v9 = v7;\n        }\n        a2 = (__int64)src;\n        memcpy((char *)v8 + v13, src, n);\n      }\n      v13 += n;\n    }\n  }\n  v6 = *__errno_location();\n  if ( v6 )\n  {\n    free(ptr);\n    free(v8);\n    *__errno_location() = v6;\n    return 0LL;\n  }\n  else\n  {\n    if ( compar )\n    {\n      if ( nmemb )\n      {\n        a2 = nmemb;\n        qsort(ptr, nmemb, 0x10uLL, compar);\n      }\n      v8 = sub_1745E(v13 + 1, a2);\n      v13 = 0LL;\n      for ( i = 0LL; i < nmemb; ++i )\n      {\n        dest = (char *)v8 + v13;\n        v5 = stpcpy((char *)v8 + v13, *((const char **)ptr + 2 * i));\n        v13 += v5 - dest + 1;\n        free(*((void **)ptr + 2 * i));\n      }\n      free(ptr);\n    }\n    else if ( v13 == v9 )\n    {\n      v8 = sub_17497(v8, v13 + 1);\n    }\n    *((_BYTE *)v8 + v13) = 0;\n    return v8;\n  }\n}\n",
  "0x14e29": "__int64 __fastcall sub_14E29(mystruct_1 *a1)\n{\n  return *(_QWORD *)&a1->mem1_80;\n}\n",
  "0x14e3f": "__int64 __fastcall sub_14E3F(mystruct_1 *a1)\n{\n  return *(_QWORD *)&a1->mem1_112;\n}\n",
  "0x14e55": "__int64 __fastcall sub_14E55(mystruct_1 *a1)\n{\n  return *(_QWORD *)&a1->mem1_96;\n}\n",
  "0x14e7e": "__int64 __fastcall sub_14E7E(mystruct_1 *a1)\n{\n  return *(_QWORD *)&a1->mem1_72;\n}\n",
  "0x14e98": "__int64 __fastcall sub_14E98(mystruct_1 *a1)\n{\n  return *(_QWORD *)&a1->mem1_104;\n}\n",
  "0x14eb2": "__int64 __fastcall sub_14EB2(mystruct_1 *a1)\n{\n  return *(_QWORD *)&a1->mem1_88;\n}\n",
  "0x15457": "__int64 __fastcall sub_15457(int a1, const char *a2, mystruct_1 *a3, mystruct_2 *a4, char a5)\n{\n  __time_t v6; // rbx\n  int v7; // ebx\n  int v11; // [rsp+24h] [rbp-14Ch]\n  int v12; // [rsp+28h] [rbp-148h]\n  int v13; // [rsp+2Ch] [rbp-144h]\n  int v14; // [rsp+30h] [rbp-140h]\n  int v15; // [rsp+30h] [rbp-140h]\n  int i; // [rsp+34h] [rbp-13Ch]\n  int j; // [rsp+38h] [rbp-138h]\n  int v18; // [rsp+3Ch] [rbp-134h]\n  int v19; // [rsp+40h] [rbp-130h]\n  int v20; // [rsp+50h] [rbp-120h]\n  int v21; // [rsp+54h] [rbp-11Ch]\n  __int64 v22; // [rsp+58h] [rbp-118h]\n  mystruct_3 *v23; // [rsp+60h] [rbp-110h]\n  __int64 v24; // [rsp+68h] [rbp-108h]\n  __time_t v25; // [rsp+70h] [rbp-100h]\n  __int64 v26; // [rsp+78h] [rbp-F8h]\n  __int64 v27; // [rsp+88h] [rbp-E8h]\n  __int64 v28; // [rsp+90h] [rbp-E0h] BYREF\n  int v29; // [rsp+98h] [rbp-D8h]\n  char v30; // [rsp+9Ch] [rbp-D4h]\n  struct timespec times; // [rsp+A0h] [rbp-D0h] BYREF\n  __int64 v32; // [rsp+B0h] [rbp-C0h]\n  __int64 v33; // [rsp+B8h] [rbp-B8h]\n  struct stat v34; // [rsp+C0h] [rbp-B0h] BYREF\n  unsigned __int64 v35; // [rsp+158h] [rbp-18h]\n\n  v35 = __readfsqword(0x28u);\n  v24 = *(_QWORD *)&a3->mem1_88;\n  v22 = *(_QWORD *)&a4->mem2_88;\n  v18 = sub_14E55(a3);\n  v11 = sub_14E55((mystruct_1 *)a4);\n  if ( (a5 & 1) == 0 )\n    goto LABEL_55;\n  v23 = 0LL;\n  if ( v24 == v22 && v18 == v11 )\n    return 0LL;\n  if ( v24 < v22 - 1 )\n    return 0xFFFFFFFFLL;\n  if ( v22 < v24 - 1 )\n    return 1LL;\n  if ( !qword_24760 )\n    qword_24760 = (__int64)sub_10C1E(\n                             0x10uLL,\n                             0LL,\n                             (unsigned __int64 (__fastcall *)(__int64, unsigned __int64))sub_153B8,\n                             (bool (__fastcall *)(__int64, __int64))sub_153E5,\n                             (size_t)&free);\n  if ( !qword_24760 )\n    goto LABEL_18;\n  if ( !qword_24768 )\n  {\n    qword_24768 = (__int64)malloc(0x10uLL);\n    if ( !qword_24768 )\n    {\nLABEL_18:\n      if ( qword_24760 )\n      {\n        v28 = *(_QWORD *)&a3->mem1_0;\n        v23 = (mystruct_3 *)sub_10569((mystruct_1 *)qword_24760, (__int64)&v28);\n      }\n      if ( !v23 )\n      {\n        v23 = (mystruct_3 *)&v28;\n        v29 = 2000000000;\n        v30 = 0;\n      }\n      goto LABEL_22;\n    }\n    *(_DWORD *)(qword_24768 + 8) = 2000000000;\n    *(_BYTE *)(qword_24768 + 12) = 0;\n  }\n  *(_QWORD *)qword_24768 = *(_QWORD *)&a3->mem1_0;\n  v23 = (mystruct_3 *)sub_1195F((_QWORD *)qword_24760, qword_24768);\n  if ( !v23 )\n    goto LABEL_18;\n  if ( v23 == (mystruct_3 *)qword_24768 )\n    qword_24768 = 0LL;\nLABEL_22:\n  v12 = *(_DWORD *)&v23->mem3_8;\n  if ( v23->mem3_12 != 1 )\n  {\n    v25 = *(_QWORD *)&a3->mem1_72;\n    v26 = *(_QWORD *)&a3->mem1_104;\n    v19 = sub_14E29(a3);\n    v14 = sub_14E3F(a3);\n    if ( (v14 % 10) | (v19 % 10) | (v18 % 10) )\n    {\n      v12 = 1;\n    }\n    else\n    {\n      v12 = 10;\n      v13 = v19 / 10;\n      v15 = v14 / 10;\n      for ( i = v18 / 10; v12 < *(_DWORD *)&v23->mem3_8 && !((i % 10) | (v15 % 10) | (v13 % 10)); i /= 10 )\n      {\n        if ( v12 == 1000000000 )\n        {\n          if ( (((unsigned __int8)v24 | (unsigned __int8)(v26 | v25)) & 1) == 0 )\n            v12 = 2000000000;\n          break;\n        }\n        v12 *= 10;\n        v13 /= 10;\n        v15 /= 10;\n      }\n    }\n    *(_DWORD *)&v23->mem3_8 = v12;\n    if ( v12 > 1 )\n    {\n      v27 = v22 & ~(v12 == 2000000000);\n      if ( v22 < v24 || v22 == v24 && v11 <= v18 )\n        return 1LL;\n      if ( v24 < v27 || v24 == v27 && v18 < v11 - v11 % v12 )\n        return 0xFFFFFFFFLL;\n      times.tv_sec = v25;\n      times.tv_nsec = v19;\n      v32 = v24 | (v12 == 2000000000);\n      v33 = v12 / 9 + v18;\n      if ( utimensat(a1, a2, &times, 256) )\n        return 4294967294LL;\n      v20 = fstatat(a1, a2, &v34, 256);\n      v6 = v24 ^ v34.st_mtim.tv_sec | v20;\n      if ( v6 | sub_14E55((mystruct_1 *)&v34) ^ v18 )\n      {\n        v32 = v24;\n        v33 = v18;\n        utimensat(a1, a2, &times, 256);\n      }\n      if ( v20 )\n        return 4294967294LL;\n      v21 = v12;\n      v7 = 1000000000 * (v34.st_mtim.tv_sec & 1);\n      v12 = 1;\n      for ( j = v7 + sub_14E55((mystruct_1 *)&v34); !(j % 10); j /= 10 )\n      {\n        if ( v12 == 1000000000 )\n        {\n          v12 = 2000000000;\n          break;\n        }\n        v12 *= 10;\n        if ( v12 == v21 )\n          break;\n      }\n    }\n    *(_DWORD *)&v23->mem3_8 = v12;\n    v23->mem3_12 = 1;\n  }\n  v22 = ~(v12 == 2000000000) & (unsigned __int64)v22;\n  v11 -= v11 % v12;\nLABEL_55:\n  if ( v24 < v22 )\n    return 0xFFFFFFFFLL;\n  if ( v24 > v22 )\n    return 1LL;\n  if ( v18 < v11 )\n    return 0xFFFFFFFFLL;\n  return v18 > v11;\n}\n",
  "0x15d8b": "__int64 __fastcall sub_15D8B(mystruct_1 *a1)\n{\n  int v2; // [rsp+18h] [rbp-8h]\n  int v3; // [rsp+1Ch] [rbp-4h]\n\n  v2 = 0;\n  v3 = 0;\n  if ( (*(_QWORD *)&a1->mem1_8 == 0x3FFFFFFFLL\n     || *(_QWORD *)&a1->mem1_8 == 1073741822LL\n     || *(_QWORD *)&a1->mem1_8 <= 0x3B9AC9FFuLL)\n    && (*(_QWORD *)&a1->mem1_24 == 0x3FFFFFFFLL\n     || *(_QWORD *)&a1->mem1_24 == 1073741822LL\n     || *(_QWORD *)&a1->mem1_24 < 0x3B9ACA00uLL) )\n  {\n    if ( *(_QWORD *)&a1->mem1_8 == 0x3FFFFFFFLL || *(_QWORD *)&a1->mem1_8 == 1073741822LL )\n    {\n      *(_QWORD *)&a1->mem1_0 = 0LL;\n      v2 = 1;\n      if ( *(_QWORD *)&a1->mem1_8 == 1073741822LL )\n        v3 = 1;\n    }\n    if ( *(_QWORD *)&a1->mem1_24 == 0x3FFFFFFFLL || *(_QWORD *)&a1->mem1_24 == 1073741822LL )\n    {\n      *(_QWORD *)&a1->mem1_16 = 0LL;\n      v2 = 1;\n      if ( *(_QWORD *)&a1->mem1_24 == 1073741822LL )\n        ++v3;\n    }\n    return (unsigned int)(v3 == 1) + v2;\n  }\n  else\n  {\n    *__errno_location() = 22;\n    return 0xFFFFFFFFLL;\n  }\n}\n",
  "0x15ef5": "__int64 __fastcall sub_15EF5(mystruct_1 *a1, mystruct_1 **a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rdx\n  mystruct_1 *v5; // [rsp+18h] [rbp-18h]\n\n  v5 = *a2;\n  if ( *(_QWORD *)&(*a2)->mem1_8 == 1073741822LL && *(_QWORD *)&v5->mem1_24 == 1073741822LL )\n    return 1LL;\n  if ( *(_QWORD *)&v5->mem1_8 == 0x3FFFFFFFLL && *(_QWORD *)&v5->mem1_24 == 0x3FFFFFFFLL )\n  {\n    *a2 = 0LL;\n    return 0LL;\n  }\n  else\n  {\n    if ( *(_QWORD *)&v5->mem1_8 == 1073741822LL )\n    {\n      *(_QWORD *)&v5->mem1_0 = sub_14E7E(a1);\n      *(_QWORD *)&v5->mem1_8 = v3;\n    }\n    else if ( *(_QWORD *)&v5->mem1_8 == 0x3FFFFFFFLL )\n    {\n      sub_17EA7((struct timespec *)v5);\n    }\n    if ( *(_QWORD *)&v5->mem1_24 == 1073741822LL )\n    {\n      *(_QWORD *)&v5->mem1_16 = sub_14EB2(a1);\n      *(_QWORD *)&v5->mem1_24 = v4;\n    }\n    else if ( *(_QWORD *)&v5->mem1_24 == 0x3FFFFFFFLL )\n    {\n      sub_17EA7((struct timespec *)&v5->mem1_16);\n    }\n    return 0LL;\n  }\n}\n",
  "0x16021": "int __fastcall sub_16021(int a1, const char *a2, mystruct_1 *a3)\n{\n  struct timespec *v3; // rax\n  __int64 v4; // rdx\n  __int64 v5; // rdx\n  bool v7; // al\n  struct timespec *v8; // rbx\n  __syscall_slong_t v9; // rdx\n  struct timespec *v10; // rbx\n  __syscall_slong_t v11; // rdx\n  __suseconds_t tv_usec; // rdx\n  __suseconds_t v14; // rdx\n  __int16 v16; // [rsp+2Eh] [rbp-142h]\n  int v17; // [rsp+30h] [rbp-140h]\n  int v18; // [rsp+34h] [rbp-13Ch]\n  int v19; // [rsp+34h] [rbp-13Ch]\n  struct timespec *times; // [rsp+38h] [rbp-138h] BYREF\n  struct timeval *tvp; // [rsp+40h] [rbp-130h]\n  struct timeval *p_tv_sec; // [rsp+48h] [rbp-128h]\n  __time_t v23; // [rsp+50h] [rbp-120h]\n  __time_t v24; // [rsp+58h] [rbp-118h]\n  __int64 v25[4]; // [rsp+60h] [rbp-110h] BYREF\n  __int64 v26[4]; // [rsp+80h] [rbp-F0h] BYREF\n  __time_t tv_sec; // [rsp+A0h] [rbp-D0h] BYREF\n  __suseconds_t v28; // [rsp+A8h] [rbp-C8h]\n  __time_t v29; // [rsp+B0h] [rbp-C0h]\n  __suseconds_t v30; // [rsp+B8h] [rbp-B8h]\n  struct stat v31; // [rsp+C0h] [rbp-B0h] BYREF\n  unsigned __int64 v32; // [rsp+158h] [rbp-18h]\n\n  v32 = __readfsqword(0x28u);\n  if ( a3 )\n    v3 = (struct timespec *)v25;\n  else\n    v3 = 0LL;\n  times = v3;\n  v17 = 0;\n  if ( v3 )\n  {\n    v4 = *(_QWORD *)&a3->mem1_8;\n    v25[0] = *(_QWORD *)&a3->mem1_0;\n    v25[1] = v4;\n    v5 = *(_QWORD *)&a3->mem1_24;\n    v25[2] = *(_QWORD *)&a3->mem1_16;\n    v25[3] = v5;\n    v17 = sub_15D8B((mystruct_1 *)times);\n  }\n  if ( v17 < 0 )\n    return -1;\n  if ( a1 < 0 && !a2 )\n  {\n    *__errno_location() = 9;\n    return -1;\n  }\n  if ( dword_24770 >= 0 )\n  {\n    if ( v17 == 2 )\n    {\n      if ( a1 >= 0 )\n        v7 = fstat(a1, &v31) != 0;\n      else\n        v7 = stat(a2, &v31) != 0;\n      if ( v7 )\n        return -1;\n      if ( times->tv_nsec == 1073741822 )\n      {\n        v8 = times;\n        times->tv_sec = sub_14E7E((mystruct_1 *)&v31);\n        v8->tv_nsec = v9;\n      }\n      else if ( times[1].tv_nsec == 1073741822 )\n      {\n        v10 = times + 1;\n        times[1].tv_sec = sub_14EB2((mystruct_1 *)&v31);\n        v10->tv_nsec = v11;\n      }\n      v17 = 3;\n    }\n    if ( a1 < 0 )\n    {\n      v18 = utimensat(-100, a2, times, 0);\n      if ( v18 > 0 )\n        *__errno_location() = 38;\n      if ( !v18 || *__errno_location() != 38 )\n      {\n        dword_24770 = 1;\n        return v18;\n      }\n    }\n    if ( a1 >= 0 )\n    {\n      v19 = futimens(a1, times);\n      if ( v19 > 0 )\n        *__errno_location() = 38;\n      if ( !v19 || *__errno_location() != 38 )\n      {\n        dword_24770 = 1;\n        return v19;\n      }\n    }\n  }\n  dword_24770 = -1;\n  dword_24774 = -1;\n  if ( !v17 )\n    goto LABEL_45;\n  if ( v17 != 3 && (a1 >= 0 ? fstat(a1, &v31) != 0 : stat(a2, &v31) != 0) )\n    return -1;\n  if ( times && (unsigned __int8)sub_15EF5((mystruct_1 *)&v31, (mystruct_1 **)&times) )\n    return 0;\nLABEL_45:\n  if ( times )\n  {\n    v26[0] = times->tv_sec;\n    v26[1] = times->tv_nsec / 1000;\n    v26[2] = times[1].tv_sec;\n    v26[3] = times[1].tv_nsec / 1000;\n    tvp = (struct timeval *)v26;\n  }\n  else\n  {\n    tvp = 0LL;\n  }\n  if ( a1 < 0 )\n    return futimesat(-100, a2, tvp);\n  if ( futimesat(a1, 0LL, tvp) )\n  {\n    if ( a2 )\n      return utimes(a2, tvp);\n    else\n      return -1;\n  }\n  else\n  {\n    if ( tvp )\n    {\n      LOBYTE(v16) = tvp->tv_usec > 499999;\n      HIBYTE(v16) = tvp[1].tv_usec > 499999;\n      if ( v16 )\n      {\n        if ( !fstat(a1, &v31) )\n        {\n          v23 = v31.st_atim.tv_sec - tvp->tv_sec;\n          v24 = v31.st_mtim.tv_sec - tvp[1].tv_sec;\n          p_tv_sec = 0LL;\n          tv_usec = tvp->tv_usec;\n          tv_sec = tvp->tv_sec;\n          v28 = tv_usec;\n          v14 = tvp[1].tv_usec;\n          v29 = tvp[1].tv_sec;\n          v30 = v14;\n          if ( (_BYTE)v16 && v23 == 1 && !sub_14E29((mystruct_1 *)&v31) )\n          {\n            p_tv_sec = (struct timeval *)&tv_sec;\n            v28 = 0LL;\n          }\n          if ( HIBYTE(v16) && v24 == 1 && !sub_14E55((mystruct_1 *)&v31) )\n          {\n            p_tv_sec = (struct timeval *)&tv_sec;\n            v30 = 0LL;\n          }\n          if ( p_tv_sec )\n            futimesat(a1, 0LL, p_tv_sec);\n        }\n      }\n    }\n    return 0;\n  }\n}\n",
  "0x16694": "int __fastcall sub_16694(const char *a1, mystruct_1 *a2)\n{\n  struct timespec *v2; // rax\n  __int64 v3; // rdx\n  __int64 v4; // rdx\n  struct timespec *v6; // rbx\n  __syscall_slong_t v7; // rdx\n  struct timespec *v8; // rbx\n  __syscall_slong_t v9; // rdx\n  int v10; // [rsp+10h] [rbp-E0h]\n  int v11; // [rsp+14h] [rbp-DCh]\n  struct timespec *times; // [rsp+18h] [rbp-D8h] BYREF\n  __int64 v13[4]; // [rsp+20h] [rbp-D0h] BYREF\n  struct stat v14; // [rsp+40h] [rbp-B0h] BYREF\n  unsigned __int64 v15; // [rsp+D8h] [rbp-18h]\n\n  v15 = __readfsqword(0x28u);\n  if ( a2 )\n    v2 = (struct timespec *)v13;\n  else\n    v2 = 0LL;\n  times = v2;\n  v10 = 0;\n  if ( v2 )\n  {\n    v3 = *(_QWORD *)&a2->mem1_8;\n    v13[0] = *(_QWORD *)&a2->mem1_0;\n    v13[1] = v3;\n    v4 = *(_QWORD *)&a2->mem1_24;\n    v13[2] = *(_QWORD *)&a2->mem1_16;\n    v13[3] = v4;\n    v10 = sub_15D8B((mystruct_1 *)times);\n  }\n  if ( v10 < 0 )\n    return -1;\n  if ( dword_24774 >= 0 )\n  {\n    if ( v10 == 2 )\n    {\n      if ( lstat(a1, &v14) )\n        return -1;\n      if ( times->tv_nsec == 1073741822 )\n      {\n        v6 = times;\n        times->tv_sec = sub_14E7E((mystruct_1 *)&v14);\n        v6->tv_nsec = v7;\n      }\n      else if ( times[1].tv_nsec == 1073741822 )\n      {\n        v8 = times + 1;\n        times[1].tv_sec = sub_14EB2((mystruct_1 *)&v14);\n        v8->tv_nsec = v9;\n      }\n      v10 = 3;\n    }\n    v11 = utimensat(-100, a1, times, 256);\n    if ( v11 > 0 )\n      *__errno_location() = 38;\n    if ( !v11 || *__errno_location() != 38 )\n    {\n      dword_24770 = 1;\n      dword_24774 = 1;\n      return v11;\n    }\n  }\n  dword_24774 = -1;\n  if ( !v10 )\n    goto LABEL_37;\n  if ( v10 != 3 && lstat(a1, &v14) )\n    return -1;\n  if ( times && (unsigned __int8)sub_15EF5((mystruct_1 *)&v14, (mystruct_1 **)&times) )\n    return 0;\nLABEL_37:\n  if ( !v10 && lstat(a1, &v14) )\n    return -1;\n  if ( (v14.st_mode & 0xF000) != 40960 )\n    return sub_16021(-1, a1, (mystruct_1 *)times);\n  *__errno_location() = 38;\n  return -1;\n}\n",
  "0x16974": "int __fastcall sub_16974(FILE *a1, const char *a2, const char *a3, const char *a4, mystruct_1 *a5, __int64 a6)\n{\n  char *v6; // rax\n  char *v7; // rax\n  int result; // eax\n  __int64 v9; // rbx\n  char *v10; // rax\n  __int64 v11; // r12\n  __int64 v12; // rbx\n  char *v13; // rax\n  __int64 v14; // r13\n  __int64 v15; // r12\n  __int64 v16; // rbx\n  char *v17; // rax\n  __int64 v18; // r14\n  __int64 v19; // r13\n  __int64 v20; // r12\n  __int64 v21; // rbx\n  char *v22; // rax\n  __int64 v23; // r13\n  __int64 v24; // r15\n  __int64 v25; // r14\n  __int64 v26; // r12\n  __int64 v27; // rbx\n  char *v28; // rax\n  __int64 v29; // r14\n  __int64 v30; // r13\n  __int64 v31; // r15\n  __int64 v32; // r12\n  __int64 v33; // rbx\n  char *v34; // rax\n  __int64 v35; // r15\n  __int64 v36; // r14\n  __int64 v37; // r13\n  __int64 v38; // r12\n  __int64 v39; // rbx\n  char *v40; // rax\n  __int64 v41; // r15\n  __int64 v42; // r14\n  __int64 v43; // r13\n  __int64 v44; // r12\n  __int64 v45; // rbx\n  char *v46; // rax\n  __int64 v47; // r15\n  __int64 v48; // r14\n  __int64 v49; // r13\n  __int64 v50; // r12\n  __int64 v51; // rbx\n  char *v52; // rax\n  __int64 v53; // r15\n  __int64 v54; // r14\n  __int64 v55; // r13\n  __int64 v56; // r12\n  __int64 v57; // rbx\n  char *v58; // rax\n  __int64 v59; // [rsp+0h] [rbp-80h]\n  __int64 v60; // [rsp+0h] [rbp-80h]\n  __int64 v61; // [rsp+8h] [rbp-78h]\n  __int64 v62; // [rsp+8h] [rbp-78h]\n  __int64 v63; // [rsp+8h] [rbp-78h]\n  __int64 v64; // [rsp+10h] [rbp-70h]\n  __int64 v65; // [rsp+10h] [rbp-70h]\n  __int64 v66; // [rsp+10h] [rbp-70h]\n  __int64 v67; // [rsp+10h] [rbp-70h]\n  __int64 v68; // [rsp+18h] [rbp-68h]\n  __int64 v69; // [rsp+18h] [rbp-68h]\n  __int64 v70; // [rsp+18h] [rbp-68h]\n  __int64 v71; // [rsp+18h] [rbp-68h]\n  __int64 v72; // [rsp+18h] [rbp-68h]\n\n  if ( a2 )\n    fprintf(a1, \"%s (%s) %s\\n\", a2, a3, a4);\n  else\n    fprintf(a1, \"%s %s\\n\", a3, a4);\n  v6 = gettext(\"(C)\");\n  fprintf(a1, \"Copyright %s %d Free Software Foundation, Inc.\", v6, 2020LL);\n  fputc_unlocked(10, a1);\n  v7 = gettext(\n         \"License GPLv3+: GNU GPL version 3 or later <%s>.\\n\"\n         \"This is free software: you are free to change and redistribute it.\\n\"\n         \"There is NO WARRANTY, to the extent permitted by law.\\n\");\n  fprintf(a1, v7, \"https://gnu.org/licenses/gpl.html\");\n  fputc_unlocked(10, a1);\n  result = a6;\n  switch ( a6 )\n  {\n    case 0LL:\n      return result;\n    case 1LL:\n      v9 = *(_QWORD *)&a5->mem1_0;\n      v10 = gettext(\"Written by %s.\\n\");\n      result = fprintf(a1, v10, v9);\n      break;\n    case 2LL:\n      v11 = *(_QWORD *)&a5->mem1_8;\n      v12 = *(_QWORD *)&a5->mem1_0;\n      v13 = gettext(\"Written by %s and %s.\\n\");\n      result = fprintf(a1, v13, v12, v11);\n      break;\n    case 3LL:\n      v14 = *(_QWORD *)&a5->mem1_16;\n      v15 = *(_QWORD *)&a5->mem1_8;\n      v16 = *(_QWORD *)&a5->mem1_0;\n      v17 = gettext(\"Written by %s, %s, and %s.\\n\");\n      result = fprintf(a1, v17, v16, v15, v14);\n      break;\n    case 4LL:\n      v18 = *(_QWORD *)&a5->mem1_24;\n      v19 = *(_QWORD *)&a5->mem1_16;\n      v20 = *(_QWORD *)&a5->mem1_8;\n      v21 = *(_QWORD *)&a5->mem1_0;\n      v22 = gettext(\"Written by %s, %s, %s,\\nand %s.\\n\");\n      result = fprintf(a1, v22, v21, v20, v19, v18);\n      break;\n    case 5LL:\n      v23 = *(_QWORD *)&a5->mem1_32;\n      v24 = *(_QWORD *)&a5->mem1_24;\n      v25 = *(_QWORD *)&a5->mem1_16;\n      v26 = *(_QWORD *)&a5->mem1_8;\n      v27 = *(_QWORD *)&a5->mem1_0;\n      v28 = gettext(\"Written by %s, %s, %s,\\n%s, and %s.\\n\");\n      result = fprintf(a1, v28, v27, v26, v25, v24, v23);\n      break;\n    case 6LL:\n      v29 = *(_QWORD *)&a5->mem1_40;\n      v30 = *(_QWORD *)&a5->mem1_32;\n      v68 = *(_QWORD *)&a5->mem1_24;\n      v31 = *(_QWORD *)&a5->mem1_16;\n      v32 = *(_QWORD *)&a5->mem1_8;\n      v33 = *(_QWORD *)&a5->mem1_0;\n      v34 = gettext(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\");\n      result = fprintf(a1, v34, v33, v32, v31, v68, v30, v29);\n      break;\n    case 7LL:\n      v35 = *(_QWORD *)&a5->mem1_48;\n      v36 = *(_QWORD *)&a5->mem1_40;\n      v37 = *(_QWORD *)&a5->mem1_32;\n      v69 = *(_QWORD *)&a5->mem1_24;\n      v64 = *(_QWORD *)&a5->mem1_16;\n      v38 = *(_QWORD *)&a5->mem1_8;\n      v39 = *(_QWORD *)&a5->mem1_0;\n      v40 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\");\n      result = fprintf(a1, v40, v39, v38, v64, v69, v37, v36, v35);\n      break;\n    case 8LL:\n      v70 = *(_QWORD *)&a5->mem1_56;\n      v41 = *(_QWORD *)&a5->mem1_48;\n      v42 = *(_QWORD *)&a5->mem1_40;\n      v43 = *(_QWORD *)&a5->mem1_32;\n      v65 = *(_QWORD *)&a5->mem1_24;\n      v61 = *(_QWORD *)&a5->mem1_16;\n      v44 = *(_QWORD *)&a5->mem1_8;\n      v45 = *(_QWORD *)&a5->mem1_0;\n      v46 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\");\n      result = fprintf(a1, v46, v45, v44, v61, v65, v43, v42, v41, v70);\n      break;\n    case 9LL:\n      v71 = *(_QWORD *)&a5->mem1_64;\n      v66 = *(_QWORD *)&a5->mem1_56;\n      v47 = *(_QWORD *)&a5->mem1_48;\n      v48 = *(_QWORD *)&a5->mem1_40;\n      v49 = *(_QWORD *)&a5->mem1_32;\n      v62 = *(_QWORD *)&a5->mem1_24;\n      v59 = *(_QWORD *)&a5->mem1_16;\n      v50 = *(_QWORD *)&a5->mem1_8;\n      v51 = *(_QWORD *)&a5->mem1_0;\n      v52 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\");\n      result = fprintf(a1, v52, v51, v50, v59, v62, v49, v48, v47, v66, v71);\n      break;\n    default:\n      v72 = *(_QWORD *)&a5->mem1_64;\n      v67 = *(_QWORD *)&a5->mem1_56;\n      v53 = *(_QWORD *)&a5->mem1_48;\n      v54 = *(_QWORD *)&a5->mem1_40;\n      v55 = *(_QWORD *)&a5->mem1_32;\n      v63 = *(_QWORD *)&a5->mem1_24;\n      v60 = *(_QWORD *)&a5->mem1_16;\n      v56 = *(_QWORD *)&a5->mem1_8;\n      v57 = *(_QWORD *)&a5->mem1_0;\n      v58 = gettext(\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\");\n      result = fprintf(a1, v58, v57, v56, v60, v63, v55, v54, v53, v67, v72);\n      break;\n  }\n  return result;\n}\n",
  "0x16fd9": "unsigned __int64 __fastcall sub_16FD9(FILE *a1, const char *a2, const char *a3, const char *a4, mystruct_1 *a5)\n{\n  __int64 *v5; // rax\n  unsigned __int64 i; // [rsp+38h] [rbp-68h]\n  __int64 v8[11]; // [rsp+40h] [rbp-60h] BYREF\n  unsigned __int64 v9; // [rsp+98h] [rbp-8h]\n\n  v9 = __readfsqword(0x28u);\n  for ( i = 0LL; i <= 9; ++i )\n  {\n    if ( *(_DWORD *)&a5->mem1_0 > 0x2Fu )\n    {\n      v5 = *(__int64 **)&a5->mem1_8;\n      *(_QWORD *)&a5->mem1_8 = v5 + 1;\n    }\n    else\n    {\n      v5 = (__int64 *)(*(_QWORD *)&a5->mem1_16 + *(unsigned int *)&a5->mem1_0);\n      *(_DWORD *)&a5->mem1_0 += 8;\n    }\n    v8[i] = *v5;\n    if ( !v8[i] )\n      break;\n  }\n  sub_16974(a1, a2, a3, a4, (mystruct_1 *)v8, i);\n  return v9 - __readfsqword(0x28u);\n}\n",
  "0x1779a": "__int64 __fastcall sub_1779A(mystruct_1 *a1)\n{\n  __int64 v2; // rax\n\n  if ( *(_QWORD *)&a1->mem1_40 > *(_QWORD *)&a1->mem1_32 )\n    return 0LL;\n  if ( (*(_DWORD *)&a1->mem1_0 & 0x100) != 0 )\n    v2 = *(_QWORD *)&a1->mem1_88 - *(_QWORD *)&a1->mem1_72;\n  else\n    v2 = 0LL;\n  return *(_QWORD *)&a1->mem1_16 - *(_QWORD *)&a1->mem1_8 + v2;\n}\n",
  "0x1819e": "mystruct_1 *__fastcall sub_1819E(__int64 a1, __int64 a2)\n{\n  mystruct_1 *result; // rax\n\n  result = (mystruct_1 *)sub_1745E(0x18uLL, a2);\n  *(_QWORD *)&result->mem1_0 = a1;\n  *(_QWORD *)&result->mem1_16 = 0LL;\n  *(_QWORD *)&result->mem1_8 = *(_QWORD *)&result->mem1_16;\n  return result;\n}\n",
  "0x18257": "unsigned __int64 __fastcall sub_18257(mystruct_1 *a1, unsigned __int64 a2)\n{\n  unsigned __int64 v3; // [rsp+10h] [rbp-60h]\n  unsigned __int64 v4; // [rsp+18h] [rbp-58h]\n  size_t v5; // [rsp+20h] [rbp-50h]\n  __int64 v6; // [rsp+20h] [rbp-50h]\n  unsigned __int64 v7; // [rsp+28h] [rbp-48h]\n  _QWORD *v8; // [rsp+30h] [rbp-40h]\n  unsigned __int64 v9; // [rsp+38h] [rbp-38h]\n  unsigned __int64 v10; // [rsp+48h] [rbp-28h]\n  char v11[8]; // [rsp+60h] [rbp-10h] BYREF\n  unsigned __int64 v12; // [rsp+68h] [rbp-8h]\n\n  v12 = __readfsqword(0x28u);\n  v8 = *(_QWORD **)&a1->mem1_0;\n  v3 = *(_QWORD *)&a1->mem1_8;\n  v4 = *(_QWORD *)&a1->mem1_16;\n  v9 = a2 + 1;\n  while ( 1 )\n  {\n    if ( v4 < a2 )\n    {\n      v5 = 0LL;\n      v7 = v4;\n      do\n      {\n        v7 = sub_18245(v7) + 255;\n        ++v5;\n      }\n      while ( v7 < a2 );\n      sub_18B06(v8, v11, v5);\n      v6 = 0LL;\n      do\n      {\n        v3 = sub_18245(v3) + (unsigned __int8)v11[v6];\n        v4 = sub_18245(v4) + 255;\n        ++v6;\n      }\n      while ( v4 < a2 );\n    }\n    if ( v4 == a2 )\n    {\n      *(_QWORD *)&a1->mem1_16 = 0LL;\n      *(_QWORD *)&a1->mem1_8 = *(_QWORD *)&a1->mem1_16;\n      return v3;\n    }\n    v10 = (v4 - a2) % v9;\n    if ( v3 <= v4 - v10 )\n      break;\n    v3 %= v9;\n    v4 = v10 - 1;\n  }\n  *(_QWORD *)&a1->mem1_8 = v3 / v9;\n  *(_QWORD *)&a1->mem1_16 = (v4 - a2) / v9;\n  return v3 % v9;\n}\n",
  "0x18524": "mystruct_1 *__fastcall sub_18524(__int64 a1, __int64 a2)\n{\n  mystruct_1 *result; // rax\n\n  result = (mystruct_1 *)sub_1745E(0x1038uLL, a2);\n  *(_QWORD *)&result->mem1_0 = a1;\n  *(_QWORD *)&result->mem1_8 = sub_184A6;\n  *(_QWORD *)&result->mem1_16 = a2;\n  return result;\n}\n",
  "0x187ef": "mystruct_1 *__fastcall sub_187EF(const char *a1, size_t a2)\n{\n  size_t v3; // rdx\n  FILE *stream; // [rsp+10h] [rbp-10h]\n  mystruct_1 *v5; // [rsp+18h] [rbp-8h]\n\n  if ( !a2 )\n    return sub_18524(0LL, 0LL);\n  stream = 0LL;\n  if ( a1 )\n  {\n    stream = sub_1A245(a1, \"rb\");\n    if ( !stream )\n      return 0LL;\n  }\n  v5 = sub_18524((__int64)stream, (__int64)a1);\n  if ( stream )\n  {\n    v3 = 4096LL;\n    if ( a2 <= 0x1000 )\n      v3 = a2;\n    setvbuf(stream, &v5->mem1_24, 0, v3);\n  }\n  else\n  {\n    *(_QWORD *)&v5->mem1_24 = 0LL;\n    sub_18572(&v5->mem1_32, 0x800uLL, a2);\n    sub_19368(&v5->mem1_32);\n  }\n  return v5;\n}\n",
  "0x188e2": "mystruct_1 *__fastcall sub_188E2(mystruct_1 *a1, __int64 a2)\n{\n  mystruct_1 *result; // rax\n\n  result = a1;\n  *(_QWORD *)&a1->mem1_8 = a2;\n  return result;\n}\n",
  "0x18901": "mystruct_1 *__fastcall sub_18901(mystruct_1 *a1, __int64 a2)\n{\n  mystruct_1 *result; // rax\n\n  result = a1;\n  *(_QWORD *)&a1->mem1_16 = a2;\n  return result;\n}\n",
  "0x18920": "size_t __fastcall sub_18920(mystruct_1 *a1, char *a2, size_t a3)\n{\n  size_t result; // rax\n  int v4; // ebx\n  int v7; // [rsp+24h] [rbp-1Ch]\n  size_t v8; // [rsp+28h] [rbp-18h]\n\n  while ( 1 )\n  {\n    v8 = fread_unlocked(a2, 1uLL, a3, *(FILE **)&a1->mem1_0);\n    v7 = *__errno_location();\n    a2 += v8;\n    result = v8;\n    a3 -= v8;\n    if ( !a3 )\n      break;\n    if ( ferror_unlocked(*(FILE **)&a1->mem1_0) )\n      v4 = v7;\n    else\n      v4 = 0;\n    *__errno_location() = v4;\n    (*(void (__fastcall **)(_QWORD))&a1->mem1_8)(*(_QWORD *)&a1->mem1_16);\n  }\n  return result;\n}\n",
  "0x18c13": "mystruct_1 *__fastcall sub_18C13(mystruct_1 *a1, mystruct_2 *a2)\n{\n  __int64 v2; // rcx\n  __int64 v3; // rax\n  __int64 v4; // rax\n  __int64 v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rax\n  __int64 v8; // rax\n  __int64 v9; // rax\n  __int64 v10; // rax\n  __int64 v11; // rax\n  __int64 v12; // rax\n  __int64 v13; // rax\n  __int64 v14; // rax\n  __int64 v15; // rax\n  __int64 v16; // rax\n  mystruct_1 *result; // rax\n  unsigned __int64 v18; // [rsp+10h] [rbp-A0h]\n  __int64 v19; // [rsp+10h] [rbp-A0h]\n  unsigned __int64 v20; // [rsp+10h] [rbp-A0h]\n  __int64 v21; // [rsp+10h] [rbp-A0h]\n  __int64 v22; // [rsp+10h] [rbp-A0h]\n  unsigned __int64 v23; // [rsp+10h] [rbp-A0h]\n  __int64 v24; // [rsp+10h] [rbp-A0h]\n  __int64 v25; // [rsp+18h] [rbp-98h]\n  __int64 v26; // [rsp+18h] [rbp-98h]\n  __int64 v27; // [rsp+18h] [rbp-98h]\n  __int64 v28; // [rsp+18h] [rbp-98h]\n  __int64 v29; // [rsp+18h] [rbp-98h]\n  __int64 v30; // [rsp+18h] [rbp-98h]\n  __int64 v31; // [rsp+18h] [rbp-98h]\n  mystruct_3 *v32; // [rsp+20h] [rbp-90h]\n  __int64 v34; // [rsp+30h] [rbp-80h]\n  __int64 v35; // [rsp+38h] [rbp-78h]\n  __int64 v36; // [rsp+40h] [rbp-70h]\n  __int64 v37; // [rsp+50h] [rbp-60h]\n  __int64 v38; // [rsp+60h] [rbp-50h]\n  __int64 v39; // [rsp+70h] [rbp-40h]\n  __int64 v40; // [rsp+78h] [rbp-38h]\n  __int64 v41; // [rsp+80h] [rbp-30h]\n  __int64 v42; // [rsp+90h] [rbp-20h]\n  __int64 v43; // [rsp+A0h] [rbp-10h]\n\n  v18 = *(_QWORD *)&a1->mem1_2048;\n  v2 = *(_QWORD *)&a1->mem1_2056;\n  ++*(_QWORD *)&a1->mem1_2064;\n  v25 = v2 + *(_QWORD *)&a1->mem1_2064;\n  v32 = (mystruct_3 *)a1;\n  do\n  {\n    v19 = *(_QWORD *)&v32->mem3_1024 - (v18 ^ (v18 << 21)) - 1;\n    v34 = *(_QWORD *)&v32->mem3_0;\n    v35 = sub_18BCF((__int64)a1, *(_QWORD *)&v32->mem3_0) + v19 + v25;\n    *(_QWORD *)&v32->mem3_0 = v35;\n    v3 = sub_18BCF((__int64)a1, (unsigned int)v35 >> 8);\n    v26 = sub_18BB5(v34 + v3);\n    *(_QWORD *)&a2->mem2_0 = v26;\n    v20 = (v19 ^ ((unsigned __int64)sub_18BB5(v19) >> 5)) + *(_QWORD *)&v32->mem3_1032;\n    v36 = *(_QWORD *)&v32->mem3_8;\n    v4 = sub_18BCF((__int64)a1, v36);\n    *(_QWORD *)&v32->mem3_8 = v4 + v20 + v26;\n    v5 = sub_18BCF((__int64)a1, (unsigned int)(v4 + v20 + v26) >> 8);\n    v27 = sub_18BB5(v36 + v5);\n    *(_QWORD *)&a2->mem2_8 = v27;\n    v21 = (v20 ^ (v20 << 12)) + *(_QWORD *)&v32->mem3_1040;\n    v37 = *(_QWORD *)&v32->mem3_16;\n    v6 = sub_18BCF((__int64)a1, v37);\n    *(_QWORD *)&v32->mem3_16 = v6 + v21 + v27;\n    v7 = sub_18BCF((__int64)a1, (unsigned int)(v6 + v21 + v27) >> 8);\n    v28 = sub_18BB5(v37 + v7);\n    *(_QWORD *)&a2->mem2_16 = v28;\n    v18 = (v21 ^ ((unsigned __int64)sub_18BB5(v21) >> 33)) + *(_QWORD *)&v32->mem3_1048;\n    v38 = *(_QWORD *)&v32->mem3_24;\n    v8 = sub_18BCF((__int64)a1, v38);\n    *(_QWORD *)&v32->mem3_24 = v8 + v18 + v28;\n    v9 = sub_18BCF((__int64)a1, (unsigned int)(v8 + v18 + v28) >> 8);\n    v25 = sub_18BB5(v38 + v9);\n    *(_QWORD *)&a2->mem2_24 = v25;\n    a2 = (mystruct_2 *)((char *)a2 + 32);\n    v32 = (mystruct_3 *)((char *)v32 + 32);\n  }\n  while ( v32 < (mystruct_3 *)&a1->mem1_1024 );\n  do\n  {\n    v22 = *(_QWORD *)&v32[-1].gap1061[3168] - (v18 ^ (v18 << 21)) - 1;\n    v39 = *(_QWORD *)&v32->mem3_0;\n    v40 = sub_18BCF((__int64)a1, *(_QWORD *)&v32->mem3_0) + v22 + v25;\n    *(_QWORD *)&v32->mem3_0 = v40;\n    v10 = sub_18BCF((__int64)a1, (unsigned int)v40 >> 8);\n    v29 = sub_18BB5(v39 + v10);\n    *(_QWORD *)&a2->mem2_0 = v29;\n    v23 = (v22 ^ ((unsigned __int64)sub_18BB5(v22) >> 5)) + *(_QWORD *)&v32[-1].gap1061[3176];\n    v41 = *(_QWORD *)&v32->mem3_8;\n    v11 = sub_18BCF((__int64)a1, v41);\n    *(_QWORD *)&v32->mem3_8 = v11 + v23 + v29;\n    v12 = sub_18BCF((__int64)a1, (unsigned int)(v11 + v23 + v29) >> 8);\n    v30 = sub_18BB5(v41 + v12);\n    *(_QWORD *)&a2->mem2_8 = v30;\n    v24 = (v23 ^ (v23 << 12)) + *(_QWORD *)&v32[-1].gap1061[3184];\n    v42 = *(_QWORD *)&v32->mem3_16;\n    v13 = sub_18BCF((__int64)a1, v42);\n    *(_QWORD *)&v32->mem3_16 = v13 + v24 + v30;\n    v14 = sub_18BCF((__int64)a1, (unsigned int)(v13 + v24 + v30) >> 8);\n    v31 = sub_18BB5(v42 + v14);\n    *(_QWORD *)&a2->mem2_16 = v31;\n    v18 = (v24 ^ ((unsigned __int64)sub_18BB5(v24) >> 33)) + *(_QWORD *)&v32[-1].gap1061[3192];\n    v43 = *(_QWORD *)&v32->mem3_24;\n    v15 = sub_18BCF((__int64)a1, v43);\n    *(_QWORD *)&v32->mem3_24 = v15 + v18 + v31;\n    v16 = sub_18BCF((__int64)a1, (unsigned int)(v15 + v18 + v31) >> 8);\n    v25 = sub_18BB5(v43 + v16);\n    *(_QWORD *)&a2->mem2_24 = v25;\n    a2 = (mystruct_2 *)((char *)a2 + 32);\n    v32 = (mystruct_3 *)((char *)v32 + 32);\n  }\n  while ( v32 < (mystruct_3 *)&a1->mem1_2048 );\n  *(_QWORD *)&a1->mem1_2048 = v18;\n  result = a1;\n  *(_QWORD *)&a1->mem1_2056 = v25;\n  return result;\n}\n",
  "0x19368": "mystruct_1 *__fastcall sub_19368(mystruct_1 *a1)\n{\n  mystruct_1 *result; // rax\n  int i; // [rsp+10h] [rbp-48h]\n  int j; // [rsp+14h] [rbp-44h]\n  __int64 v4; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v5; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v6; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v7; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v8; // [rsp+18h] [rbp-40h]\n  unsigned __int64 v9; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v10; // [rsp+20h] [rbp-38h]\n  __int64 v11; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v12; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v13; // [rsp+20h] [rbp-38h]\n  __int64 v14; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v15; // [rsp+20h] [rbp-38h]\n  unsigned __int64 v16; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v17; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v18; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v19; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v20; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v21; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v22; // [rsp+28h] [rbp-30h]\n  unsigned __int64 v23; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v24; // [rsp+30h] [rbp-28h]\n  __int64 v25; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v26; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v27; // [rsp+30h] [rbp-28h]\n  __int64 v28; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v29; // [rsp+30h] [rbp-28h]\n  unsigned __int64 v30; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v31; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v32; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v33; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v34; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v35; // [rsp+38h] [rbp-20h]\n  unsigned __int64 v36; // [rsp+38h] [rbp-20h]\n  __int64 v37; // [rsp+40h] [rbp-18h]\n  __int64 v38; // [rsp+40h] [rbp-18h]\n  unsigned __int64 v39; // [rsp+40h] [rbp-18h]\n  __int64 v40; // [rsp+40h] [rbp-18h]\n  __int64 v41; // [rsp+40h] [rbp-18h]\n  unsigned __int64 v42; // [rsp+40h] [rbp-18h]\n  __int64 v43; // [rsp+40h] [rbp-18h]\n  unsigned __int64 v44; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v45; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v46; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v47; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v48; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v49; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v50; // [rsp+48h] [rbp-10h]\n  unsigned __int64 v51; // [rsp+50h] [rbp-8h]\n  __int64 v52; // [rsp+50h] [rbp-8h]\n  unsigned __int64 v53; // [rsp+50h] [rbp-8h]\n  unsigned __int64 v54; // [rsp+50h] [rbp-8h]\n  __int64 v55; // [rsp+50h] [rbp-8h]\n  unsigned __int64 v56; // [rsp+50h] [rbp-8h]\n  unsigned __int64 v57; // [rsp+50h] [rbp-8h]\n\n  v4 = 0x647C4677A2884B7CLL;\n  v9 = 0xB9F8B322C73AC862LL;\n  v16 = 0x8C0EA5053D4712A0LL;\n  v23 = 0xB29B2E824A595524LL;\n  v30 = 0x82F053DB8355E0CELL;\n  v37 = 0x48FE4A0FA5A09315LL;\n  v44 = 0xAE985BF2CBFC89EDLL;\n  v51 = 0x98F5704F6C44C0ABLL;\n  for ( i = 0; i <= 255; i += 8 )\n  {\n    v10 = *((_QWORD *)&a1->mem1_8 + i) + v9;\n    v17 = *((_QWORD *)&a1->mem1_16 + i) + v16;\n    v24 = *((_QWORD *)&a1->mem1_24 + i) + v23;\n    v31 = *((_QWORD *)&a1->mem1_32 + i) + v30;\n    v38 = *((_QWORD *)&a1->mem1_40 + i) + v37;\n    v45 = *((_QWORD *)&a1->mem1_48 + i) + v44;\n    v52 = *((_QWORD *)&a1->mem1_56 + i) + v51;\n    v5 = *((_QWORD *)&a1->mem1_0 + i) + v4 - v31;\n    v39 = ((unsigned __int64)sub_18BB5(v52) >> 9) ^ v38;\n    v53 = v5 + v52;\n    v11 = v10 - v39;\n    v46 = (v5 << 9) ^ v45;\n    v6 = v11 + v5;\n    v18 = v17 - v46;\n    v54 = ((unsigned __int64)sub_18BB5(v11) >> 23) ^ v53;\n    v12 = v18 + v11;\n    v25 = v24 - v54;\n    v4 = (v18 << 15) ^ v6;\n    v19 = v25 + v18;\n    v32 = v31 - v4;\n    v9 = ((unsigned __int64)sub_18BB5(v25) >> 14) ^ v12;\n    v26 = v32 + v25;\n    v40 = v39 - v9;\n    v16 = (v32 << 20) ^ v19;\n    v33 = v40 + v32;\n    v47 = v46 - v16;\n    v23 = ((unsigned __int64)sub_18BB5(v40) >> 17) ^ v26;\n    v37 = v47 + v40;\n    v51 = v54 - v23;\n    v30 = (v47 << 14) ^ v33;\n    v44 = v51 + v47;\n    *((_QWORD *)&a1->mem1_0 + i) = v4;\n    *((_QWORD *)&a1->mem1_8 + i) = v9;\n    *((_QWORD *)&a1->mem1_16 + i) = v16;\n    *((_QWORD *)&a1->mem1_24 + i) = v23;\n    *((_QWORD *)&a1->mem1_32 + i) = v30;\n    *((_QWORD *)&a1->mem1_40 + i) = v37;\n    *((_QWORD *)&a1->mem1_48 + i) = v44;\n    *((_QWORD *)&a1->mem1_56 + i) = v51;\n  }\n  for ( j = 0; j <= 255; j += 8 )\n  {\n    v13 = *((_QWORD *)&a1->mem1_8 + j) + v9;\n    v20 = *((_QWORD *)&a1->mem1_16 + j) + v16;\n    v27 = *((_QWORD *)&a1->mem1_24 + j) + v23;\n    v34 = *((_QWORD *)&a1->mem1_32 + j) + v30;\n    v41 = *((_QWORD *)&a1->mem1_40 + j) + v37;\n    v48 = *((_QWORD *)&a1->mem1_48 + j) + v44;\n    v55 = *((_QWORD *)&a1->mem1_56 + j) + v51;\n    v7 = *((_QWORD *)&a1->mem1_0 + j) + v4 - v34;\n    v42 = ((unsigned __int64)sub_18BB5(v55) >> 9) ^ v41;\n    v56 = v7 + v55;\n    v14 = v13 - v42;\n    v49 = (v7 << 9) ^ v48;\n    v8 = v14 + v7;\n    v21 = v20 - v49;\n    v57 = ((unsigned __int64)sub_18BB5(v14) >> 23) ^ v56;\n    v15 = v21 + v14;\n    v28 = v27 - v57;\n    v4 = (v21 << 15) ^ v8;\n    v22 = v28 + v21;\n    v35 = v34 - v4;\n    v9 = ((unsigned __int64)sub_18BB5(v28) >> 14) ^ v15;\n    v29 = v35 + v28;\n    v43 = v42 - v9;\n    v16 = (v35 << 20) ^ v22;\n    v36 = v43 + v35;\n    v50 = v49 - v16;\n    v23 = ((unsigned __int64)sub_18BB5(v43) >> 17) ^ v29;\n    v37 = v50 + v43;\n    v51 = v57 - v23;\n    v30 = (v50 << 14) ^ v36;\n    v44 = v51 + v50;\n    *((_QWORD *)&a1->mem1_0 + j) = v4;\n    *((_QWORD *)&a1->mem1_8 + j) = v9;\n    *((_QWORD *)&a1->mem1_16 + j) = v16;\n    *((_QWORD *)&a1->mem1_24 + j) = v23;\n    *((_QWORD *)&a1->mem1_32 + j) = v30;\n    *((_QWORD *)&a1->mem1_40 + j) = v37;\n    *((_QWORD *)&a1->mem1_48 + j) = v44;\n    *((_QWORD *)&a1->mem1_56 + j) = v51;\n  }\n  *(_QWORD *)&a1->mem1_2064 = 0LL;\n  *(_QWORD *)&a1->mem1_2056 = *(_QWORD *)&a1->mem1_2064;\n  result = a1;\n  *(_QWORD *)&a1->mem1_2048 = *(_QWORD *)&a1->mem1_2056;\n  return result;\n}\n"
 },
 "vartype": {
  "0x3fbc": {
   "stack32_1": "mystruct_1 *"
  },
  "0x450d": {
   "arg_3": "mystruct_2 *",
   "arg_4": "mystruct_1 *",
   "stack4096_1": "mystruct_1 *",
   "stack4104_1": "mystruct_2 *",
   "stack4144_1": "mystruct_2 *"
  },
  "0x489b": {
   "arg_6": "mystruct_2 *",
   "reg8_8": "mystruct_1 *",
   "stack4096_1": "mystruct_2 *",
   "stack4176_1": "mystruct_3 *"
  },
  "0x52d5": {
   "arg_2": "mystruct_3 *",
   "arg_5": "mystruct_1 *",
   "stack4096_1": "mystruct_2 *",
   "stack4112_1": "mystruct_3 *",
   "stack4144_1": "mystruct_4 *"
  },
  "0x5c29": {
   "arg_1": "mystruct_1 *",
   "reg8_1": "mystruct_1 *"
  },
  "0x5d83": {
   "arg_2": "mystruct_1 *"
  },
  "0x6905": {
   "arg_1": "mystruct_1 *"
  },
  "0x6a62": {
   "arg_1": "mystruct_1 *",
   "reg8_1": "mystruct_1 *"
  },
  "0x78e1": {
   "arg_1": "mystruct_1 *",
   "arg_2": "mystruct_2 *"
  },
  "0x7985": {
   "arg_6": "mystruct_1 *"
  },
  "0x7c6a": {
   "arg_1": "mystruct_2 *",
   "arg_4": "mystruct_1 *",
   "arg_6": "mystruct_3 *"
  },
  "0x7f19": {
   "arg_5": "mystruct_1 *"
  },
  "0x8199": {
   "arg_4": "mystruct_1 *"
  },
  "0x82f1": {
   "arg_1": "mystruct_1 *"
  },
  "0x8348": {
   "arg_3": "mystruct_1 *",
   "arg_7": "mystruct_2 *"
  },
  "0x947b": {
   "arg_5": "mystruct_1 *"
  },
  "0x9cf2": {
   "arg_1": "mystruct_2 *",
   "arg_3": "mystruct_1 *"
  },
  "0x9e5c": {
   "arg_1": "mystruct_1 *"
  },
  "0x9ea4": {
   "arg_1": "mystruct_1 *"
  },
  "0x9eec": {
   "arg_1": "mystruct_1 *"
  },
  "0xa1d4": {
   "arg_1": "mystruct_1 *"
  },
  "0xa210": {
   "arg_2": "mystruct_1 *"
  },
  "0xa404": {
   "arg_5": "mystruct_2 *",
   "arg_6": "mystruct_1 *",
   "stack4096_1": "mystruct_2 *",
   "stack4128_1": "mystruct_1 *",
   "stack4136_1": "mystruct_2 *",
   "stack4272_1": "mystruct_1 *",
   "stack4344_1": "mystruct_2 **"
  },
  "0xcf79": {
   "arg_1": "mystruct_1 *"
  },
  "0xd1e2": {
   "arg_1": "mystruct_1 *",
   "reg8_1": "mystruct_1 *"
  },
  "0xd236": {
   "arg_1": "mystruct_1 *"
  },
  "0xd27e": {
   "arg_1": "mystruct_1 *"
  },
  "0xd32b": {
   "arg_1": "mystruct_1 *",
   "arg_2": "mystruct_2 *"
  },
  "0xd43a": {
   "stack24_1": "mystruct_1 *"
  },
  "0xd4b3": {
   "stack32_1": "mystruct_1 *",
   "stack40_1": "mystruct_2 *"
  },
  "0xd5ca": {
   "arg_2": "mystruct_1 *",
   "reg8_1": "mystruct_1 *"
  },
  "0xd62c": {
   "arg_1": "mystruct_1 *",
   "stack32_1": "mystruct_2 *"
  },
  "0xfc8f": {
   "arg_3": "mystruct_1 *",
   "stack32_1": "mystruct_2 *",
   "stack40_1": "mystruct_2 *"
  },
  "0xfd2f": {
   "arg_3": "mystruct_1 *"
  },
  "0xfe61": {
   "arg_2": "mystruct_1 *"
  },
  "0x10265": {
   "arg_1": "mystruct_1 *"
  },
  "0x1027b": {
   "arg_1": "mystruct_1 *"
  },
  "0x10291": {
   "arg_1": "mystruct_1 *"
  },
  "0x102a7": {
   "arg_1": "mystruct_1 *",
   "stack8_1": "mystruct_2 *",
   "stack24_1": "mystruct_2 *"
  },
  "0x10329": {
   "arg_1": "mystruct_1 *",
   "stack8_1": "mystruct_2 *",
   "stack32_1": "mystruct_2 *"
  },
  "0x1050e": {
   "arg_1": "mystruct_1 *"
  },
  "0x10569": {
   "arg_1": "mystruct_1 *",
   "stack16_1": "mystruct_2 *",
   "stack24_1": "mystruct_2 *"
  },
  "0x10600": {
   "arg_1": "mystruct_1 *"
  },
  "0x10660": {
   "arg_1": "mystruct_1 *",
   "stack16_1": "mystruct_2 *",
   "stack24_1": "mystruct_2 *"
  },
  "0x106fe": {
   "arg_1": "mystruct_1 *",
   "stack40_1": "mystruct_2 *",
   "stack48_1": "mystruct_2 *"
  },
  "0x1079e": {
   "arg_1": "mystruct_1 *",
   "stack48_1": "mystruct_2 *",
   "stack56_1": "mystruct_2 *"
  },
  "0x1094a": {
   "arg_1": "mystruct_1 *",
   "reg8_1": "mystruct_1 *"
  },
  "0x109f8": {
   "arg_1": "mystruct_1 *",
   "stack16_1": "mystruct_2 *"
  },
  "0x10b05": {
   "arg_2": "mystruct_1 *"
  },
  "0x10c1e": {
   "arg_2": "mystruct_1 *",
   "reg8_1": "mystruct_1 *",
   "stack32_1": "mystruct_1 *",
   "stack56_1": "mystruct_1 *"
  },
  "0x10d93": {
   "arg_1": "mystruct_1 *",
   "reg8_1": "mystruct_1 *",
   "stack24_1": "mystruct_2 *",
   "stack32_1": "mystruct_3 *",
   "stack40_1": "mystruct_3 *"
  },
  "0x10e9e": {
   "arg_1": "mystruct_1 *",
   "stack24_1": "mystruct_3 *",
   "stack24_2": "mystruct_2 *",
   "stack32_1": "mystruct_3 *",
   "stack32_2": "mystruct_4 *",
   "stack32_3": "mystruct_5 *",
   "stack40_1": "mystruct_4 *",
   "stack40_2": "mystruct_5 *"
  },
  "0x10fcd": {
   "arg_1": "mystruct_1 *",
   "reg8_1": "mystruct_2 *",
   "stack24_1": "mystruct_2 *"
  },
  "0x1101c": {
   "arg_1": "mystruct_1 *",
   "arg_2": "mystruct_2 *",
   "reg8_1": "mystruct_1 *"
  },
  "0x11056": {
   "arg_1": "mystruct_1 *",
   "arg_3": "mystruct_3 **",
   "stack32_1": "mystruct_2 *",
   "stack40_1": "mystruct_3 *",
   "stack56_1": "mystruct_4 *",
   "stack72_1": "mystruct_5 *"
  },
  "0x111ef": {
   "arg_1": "mystruct_1 *",
   "arg_2": "mystruct_2 *",
   "stack32_1": "mystruct_3 *",
   "stack40_1": "mystruct_4 *",
   "stack56_1": "mystruct_5 *",
   "stack56_2": "mystruct_6 *",
   "stack64_1": "mystruct_7 *",
   "stack72_1": "mystruct_4 *"
  },
  "0x113c3": {
   "arg_1": "mystruct_1 *"
  },
  "0x115ee": {
   "arg_1": "mystruct_1 *",
   "stack40_1": "mystruct_2 *",
   "stack56_1": "mystruct_3 *",
   "stack64_1": "mystruct_4 *"
  },
  "0x119cf": {
   "arg_1": "mystruct_1 *",
   "stack24_1": "mystruct_3 *",
   "stack32_1": "mystruct_2 *",
   "stack48_1": "mystruct_3 *",
   "stack64_1": "mystruct_2 *"
  },
  "0x11cd5": {
   "arg_1": "mystruct_1 *"
  },
  "0x11d25": {
   "arg_1": "mystruct_1 *"
  },
  "0x11d53": {
   "arg_1": "mystruct_1 *",
   "arg_2": "mystruct_2 *"
  },
  "0x11dcf": {
   "arg_1": "mystruct_1 *",
   "arg_2": "mystruct_2 *"
  },
  "0x12246": {
   "arg_1": "mystruct_1 *",
   "stack8_1": "mystruct_1 *"
  },
  "0x12280": {
   "arg_1": "mystruct_1 *",
   "reg8_1": "mystruct_1 *",
   "stack24_1": "mystruct_1 *"
  },
  "0x122e2": {
   "arg_1": "mystruct_1 *",
   "reg8_1": "mystruct_1 *"
  },
  "0x1246c": {
   "arg_3": "mystruct_1 *"
  },
  "0x135ff": {
   "arg_1": "mystruct_1 *",
   "stack72_1": "mystruct_1 *"
  },
  "0x1372b": {
   "stack8_1": "mystruct_1 *"
  },
  "0x137ea": {
   "arg_2": "mystruct_1 *",
   "arg_4": "mystruct_1 *",
   "stack80_1": "mystruct_2 *"
  },
  "0x14779": {
   "arg_1": "mystruct_1 *",
   "arg_2": "mystruct_2 *"
  },
  "0x147d0": {
   "stack112_1": "mystruct_1 *"
  },
  "0x14e29": {
   "arg_1": "mystruct_1 *"
  },
  "0x14e3f": {
   "arg_1": "mystruct_1 *"
  },
  "0x14e55": {
   "arg_1": "mystruct_1 *"
  },
  "0x14e7e": {
   "arg_1": "mystruct_1 *"
  },
  "0x14e98": {
   "arg_1": "mystruct_1 *"
  },
  "0x14eb2": {
   "arg_1": "mystruct_1 *"
  },
  "0x15457": {
   "arg_3": "mystruct_1 *",
   "arg_4": "mystruct_2 *",
   "stack96_1": "mystruct_3 *"
  },
  "0x15d8b": {
   "arg_1": "mystruct_1 *"
  },
  "0x15ef5": {
   "arg_1": "mystruct_1 *",
   "arg_2": "mystruct_1 **",
   "stack24_1": "mystruct_1 *"
  },
  "0x16021": {
   "arg_3": "mystruct_1 *"
  },
  "0x16694": {
   "arg_2": "mystruct_1 *"
  },
  "0x16974": {
   "arg_5": "mystruct_1 *"
  },
  "0x16fd9": {
   "arg_5": "mystruct_1 *"
  },
  "0x1779a": {
   "arg_1": "mystruct_1 *"
  },
  "0x1819e": {
   "reg8_1": "mystruct_1 *"
  },
  "0x18257": {
   "arg_1": "mystruct_1 *"
  },
  "0x18524": {
   "reg8_1": "mystruct_1 *"
  },
  "0x187ef": {
   "reg8_1": "mystruct_1 *",
   "stack24_1": "mystruct_1 *"
  },
  "0x188e2": {
   "arg_1": "mystruct_1 *",
   "reg8_1": "mystruct_1 *"
  },
  "0x18901": {
   "arg_1": "mystruct_1 *",
   "reg8_1": "mystruct_1 *"
  },
  "0x18920": {
   "arg_1": "mystruct_1 *"
  },
  "0x18c13": {
   "arg_1": "mystruct_1 *",
   "arg_2": "mystruct_2 *",
   "reg8_15": "mystruct_1 *",
   "stack32_1": "mystruct_3 *"
  },
  "0x19368": {
   "arg_1": "mystruct_1 *",
   "reg8_1": "mystruct_1 *"
  }
 },
 "funcaddr": {
  "sub_3FBC": "0x3fbc",
  "sub_450D": "0x450d",
  "sub_489B": "0x489b",
  "sub_52D5": "0x52d5",
  "sub_5C29": "0x5c29",
  "sub_5D83": "0x5d83",
  "sub_6905": "0x6905",
  "sub_6A62": "0x6a62",
  "sub_78E1": "0x78e1",
  "sub_7985": "0x7985",
  "sub_7C6A": "0x7c6a",
  "sub_7F19": "0x7f19",
  "sub_8199": "0x8199",
  "sub_82F1": "0x82f1",
  "sub_8348": "0x8348",
  "sub_947B": "0x947b",
  "sub_9CF2": "0x9cf2",
  "sub_9E5C": "0x9e5c",
  "sub_9EA4": "0x9ea4",
  "sub_9EEC": "0x9eec",
  "sub_A1D4": "0xa1d4",
  "sub_A210": "0xa210",
  "sub_A404": "0xa404",
  "sub_CF79": "0xcf79",
  "sub_D1E2": "0xd1e2",
  "sub_D236": "0xd236",
  "sub_D27E": "0xd27e",
  "sub_D32B": "0xd32b",
  "sub_D43A": "0xd43a",
  "sub_D4B3": "0xd4b3",
  "sub_D5CA": "0xd5ca",
  "sub_D62C": "0xd62c",
  "sub_FC8F": "0xfc8f",
  "sub_FD2F": "0xfd2f",
  "sub_FE61": "0xfe61",
  "sub_10265": "0x10265",
  "sub_1027B": "0x1027b",
  "sub_10291": "0x10291",
  "sub_102A7": "0x102a7",
  "sub_10329": "0x10329",
  "sub_1050E": "0x1050e",
  "sub_10569": "0x10569",
  "sub_10600": "0x10600",
  "sub_10660": "0x10660",
  "sub_106FE": "0x106fe",
  "sub_1079E": "0x1079e",
  "sub_1094A": "0x1094a",
  "sub_109F8": "0x109f8",
  "sub_10B05": "0x10b05",
  "sub_10C1E": "0x10c1e",
  "sub_10D93": "0x10d93",
  "sub_10E9E": "0x10e9e",
  "sub_10FCD": "0x10fcd",
  "sub_1101C": "0x1101c",
  "sub_11056": "0x11056",
  "sub_111EF": "0x111ef",
  "sub_113C3": "0x113c3",
  "sub_115EE": "0x115ee",
  "sub_119CF": "0x119cf",
  "sub_11CD5": "0x11cd5",
  "sub_11D25": "0x11d25",
  "sub_11D53": "0x11d53",
  "sub_11DCF": "0x11dcf",
  "sub_12246": "0x12246",
  "sub_12280": "0x12280",
  "sub_122E2": "0x122e2",
  "sub_1246C": "0x1246c",
  "sub_135FF": "0x135ff",
  "sub_1372B": "0x1372b",
  "sub_137EA": "0x137ea",
  "sub_14779": "0x14779",
  "sub_147D0": "0x147d0",
  "sub_14E29": "0x14e29",
  "sub_14E3F": "0x14e3f",
  "sub_14E55": "0x14e55",
  "sub_14E7E": "0x14e7e",
  "sub_14E98": "0x14e98",
  "sub_14EB2": "0x14eb2",
  "sub_15457": "0x15457",
  "sub_15D8B": "0x15d8b",
  "sub_15EF5": "0x15ef5",
  "sub_16021": "0x16021",
  "sub_16694": "0x16694",
  "sub_16974": "0x16974",
  "sub_16FD9": "0x16fd9",
  "sub_1779A": "0x1779a",
  "sub_1819E": "0x1819e",
  "sub_18257": "0x18257",
  "sub_18524": "0x18524",
  "sub_187EF": "0x187ef",
  "sub_188E2": "0x188e2",
  "sub_18901": "0x18901",
  "sub_18920": "0x18920",
  "sub_18C13": "0x18c13",
  "sub_19368": "0x19368"
 },
 "function": {
  "sub_3FBC": "emit_ancillary_info",
  "sub_450D": "re_protect",
  "sub_489B": "make_dir_parents_private",
  "sub_52D5": "do_copy",
  "sub_5C29": "cp_option_init",
  "sub_5D83": "decode_preserve_arg",
  "sub_6905": "dot_or_dotdot",
  "sub_6A62": "extent_scan_free",
  "sub_78E1": "is_ancestor",
  "sub_7985": "copy_dir",
  "sub_7C6A": "set_owner",
  "sub_7F19": "set_process_security_ctx",
  "sub_8199": "set_file_security_ctx",
  "sub_82F1": "is_probably_sparse",
  "sub_8348": "copy_reg",
  "sub_947B": "same_file_ok",
  "sub_9CF2": "overwrite_ok",
  "sub_9E5C": "dest_info_init",
  "sub_9EA4": "src_info_init",
  "sub_9EEC": "abandon_move",
  "sub_A1D4": "should_dereference",
  "sub_A210": "source_is_dst_backup",
  "sub_A404": "copy_internal",
  "sub_CF79": "valid_options",
  "sub_D1E2": "cp_options_default",
  "sub_D236": "chown_failure_ok",
  "sub_D27E": "owner_failure_ok",
  "sub_D32B": "src_to_dest_compare",
  "sub_D43A": "src_to_dest_lookup",
  "sub_D4B3": "remember_copied",
  "sub_D5CA": "extent_scan_init",
  "sub_D62C": "extent_scan_read",
  "sub_FC8F": "record_file",
  "sub_FD2F": "seen_file",
  "sub_FE61": "strmode",
  "sub_10265": "hash_get_n_buckets",
  "sub_1027B": "hash_get_n_buckets_used",
  "sub_10291": "hash_get_n_entries",
  "sub_102A7": "hash_get_max_bucket_length",
  "sub_10329": "hash_table_ok",
  "sub_1050E": "safe_hasher",
  "sub_10569": "hash_lookup",
  "sub_10600": "hash_get_first",
  "sub_10660": "hash_get_next",
  "sub_106FE": "hash_get_entries",
  "sub_1079E": "hash_do_for_each",
  "sub_1094A": "hash_reset_tuning",
  "sub_109F8": "check_tuning",
  "sub_10B05": "compute_bucket_size",
  "sub_10C1E": "hash_initialize",
  "sub_10D93": "hash_clear",
  "sub_10E9E": "hash_free",
  "sub_10FCD": "allocate_entry",
  "sub_1101C": "free_entry",
  "sub_11056": "hash_find_entry",
  "sub_111EF": "transfer_entries",
  "sub_113C3": "hash_rehash",
  "sub_115EE": "hash_insert_if_absent",
  "sub_119CF": "hash_delete",
  "sub_11CD5": "triple_hash",
  "sub_11D25": "triple_hash_no_name",
  "sub_11D53": "triple_compare",
  "sub_11DCF": "triple_compare_ino_str",
  "sub_12246": "set_quoting_flags",
  "sub_12280": "set_custom_quoting",
  "sub_122E2": "quoting_options_from_style",
  "sub_1246C": "quotearg_buffer_restyled",
  "sub_135FF": "quotearg_alloc_mem",
  "sub_1372B": "quotearg_free",
  "sub_137EA": "quotearg_n_options",
  "sub_14779": "direntry_cmp_inode",
  "sub_147D0": "streamsavedir",
  "sub_14E29": "get_stat_atime_ns",
  "sub_14E3F": "get_stat_ctime_ns",
  "sub_14E55": "get_stat_mtime_ns",
  "sub_14E7E": "get_stat_atime",
  "sub_14E98": "get_stat_ctime",
  "sub_14EB2": "get_stat_mtime",
  "sub_15457": "utimecmpat",
  "sub_15D8B": "validate_timespec",
  "sub_15EF5": "update_timespec",
  "sub_16021": "fdutimens",
  "sub_16694": "lutimens",
  "sub_16974": "version_etc_arn",
  "sub_16FD9": "version_etc_va",
  "sub_1779A": "freadahead",
  "sub_1819E": "randint_new",
  "sub_18257": "randint_genmax",
  "sub_18524": "simple_new",
  "sub_187EF": "randread_new",
  "sub_188E2": "randread_set_handler",
  "sub_18901": "randread_set_handler_arg",
  "sub_18920": "readsource",
  "sub_18C13": "isaac_refill",
  "sub_19368": "isaac_seed"
 },
 "mapping": {
  "emit_ancillary_info::infomap *": [
   "0x3fbc_mystruct_1"
  ],
  "dir_attr *": [
   "0x450d_mystruct_2",
   "0x450d_mystruct_2",
   "0x450d_mystruct_2",
   "0x489b_mystruct_1",
   "0x489b_mystruct_3",
   "0x52d5_mystruct_4"
  ],
  "cp_options *": [
   "0x450d_mystruct_1",
   "0x450d_mystruct_1",
   "0x489b_mystruct_2",
   "0x489b_mystruct_2",
   "0x52d5_mystruct_1",
   "0x52d5_mystruct_2",
   "0x5c29_mystruct_1",
   "0x5d83_mystruct_1",
   "0x7985_mystruct_1",
   "0x7c6a_mystruct_2",
   "0x7f19_mystruct_1",
   "0x8199_mystruct_1",
   "0x8348_mystruct_1",
   "0x947b_mystruct_1",
   "0x9cf2_mystruct_2",
   "0x9e5c_mystruct_1",
   "0x9ea4_mystruct_1",
   "0x9eec_mystruct_1",
   "0xa1d4_mystruct_1",
   "0xa404_mystruct_1",
   "0xa404_mystruct_1",
   "0xcf79_mystruct_1",
   "0xd1e2_mystruct_1",
   "0xd236_mystruct_1",
   "0xd27e_mystruct_1"
  ],
  "extent_scan *": [
   "0x6a62_mystruct_1",
   "0xd5ca_mystruct_1",
   "0xd62c_mystruct_1"
  ],
  "stat *": [
   "0x78e1_mystruct_1",
   "0x7c6a_mystruct_1",
   "0x7c6a_mystruct_3",
   "0x82f1_mystruct_1",
   "0x8348_mystruct_2",
   "0x9cf2_mystruct_1",
   "0xa210_mystruct_1",
   "0xfc8f_mystruct_1",
   "0xfd2f_mystruct_1",
   "0x14e29_mystruct_1",
   "0x14e3f_mystruct_1",
   "0x14e55_mystruct_1",
   "0x14e7e_mystruct_1",
   "0x14e98_mystruct_1",
   "0x14eb2_mystruct_1",
   "0x15457_mystruct_1",
   "0x15457_mystruct_2",
   "0x15ef5_mystruct_1"
  ],
  "dir_list *": [
   "0x78e1_mystruct_2",
   "0xa404_mystruct_2",
   "0xa404_mystruct_2",
   "0xa404_mystruct_2",
   "0xa404_mystruct_2"
  ],
  "Src_to_dest *": [
   "0xd43a_mystruct_1",
   "0xd4b3_mystruct_1",
   "0xd4b3_mystruct_2"
  ],
  "extent_info *": [
   "0xd62c_mystruct_2"
  ],
  "F_triple *": [
   "0xfc8f_mystruct_2",
   "0xfc8f_mystruct_2"
  ],
  "Hash_table *": [
   "0x10265_mystruct_1",
   "0x1027b_mystruct_1",
   "0x10291_mystruct_1",
   "0x102a7_mystruct_1",
   "0x10329_mystruct_1",
   "0x1050e_mystruct_1",
   "0x10569_mystruct_1",
   "0x10600_mystruct_1",
   "0x10660_mystruct_1",
   "0x106fe_mystruct_1",
   "0x1079e_mystruct_1",
   "0x109f8_mystruct_1",
   "0x10c1e_mystruct_1",
   "0x10c1e_mystruct_1",
   "0x10d93_mystruct_1",
   "0x10e9e_mystruct_1",
   "0x10fcd_mystruct_1",
   "0x1101c_mystruct_1",
   "0x11056_mystruct_1",
   "0x111ef_mystruct_1",
   "0x111ef_mystruct_2",
   "0x113c3_mystruct_1",
   "0x115ee_mystruct_1",
   "0x119cf_mystruct_1"
  ],
  "hash_entry *": [
   "0x102a7_mystruct_2",
   "0x102a7_mystruct_2",
   "0x10329_mystruct_2",
   "0x10329_mystruct_2",
   "0x10569_mystruct_2",
   "0x10569_mystruct_2",
   "0x10660_mystruct_2",
   "0x10660_mystruct_2",
   "0x106fe_mystruct_2",
   "0x106fe_mystruct_2",
   "0x1079e_mystruct_2",
   "0x1079e_mystruct_2",
   "0x10d93_mystruct_2",
   "0x10d93_mystruct_3",
   "0x10d93_mystruct_3",
   "0x10e9e_mystruct_3",
   "0x10e9e_mystruct_2",
   "0x10e9e_mystruct_3",
   "0x10e9e_mystruct_4",
   "0x10e9e_mystruct_5",
   "0x10e9e_mystruct_4",
   "0x10e9e_mystruct_5",
   "0x10fcd_mystruct_2",
   "0x10fcd_mystruct_2",
   "0x1101c_mystruct_2",
   "0x11056_mystruct_2",
   "0x11056_mystruct_3",
   "0x11056_mystruct_4",
   "0x11056_mystruct_5",
   "0x111ef_mystruct_3",
   "0x111ef_mystruct_4",
   "0x111ef_mystruct_5",
   "0x111ef_mystruct_6",
   "0x111ef_mystruct_7",
   "0x111ef_mystruct_4",
   "0x115ee_mystruct_2",
   "0x115ee_mystruct_4",
   "0x119cf_mystruct_3",
   "0x119cf_mystruct_2",
   "0x119cf_mystruct_2"
  ],
  "Hash_tuning *": [
   "0x1094a_mystruct_1",
   "0x109f8_mystruct_2",
   "0x10b05_mystruct_1",
   "0x10c1e_mystruct_1",
   "0x10c1e_mystruct_1",
   "0x115ee_mystruct_3",
   "0x119cf_mystruct_3"
  ],
  "quoting_options *": [
   "0x12246_mystruct_1",
   "0x12246_mystruct_1",
   "0x12280_mystruct_1",
   "0x12280_mystruct_1",
   "0x122e2_mystruct_1",
   "0x122e2_mystruct_1",
   "0x135ff_mystruct_1",
   "0x137ea_mystruct_1"
  ],
  "slotvec *": [
   "0x1372b_mystruct_1",
   "0x137ea_mystruct_2"
  ],
  "fs_res *": [
   "0x15457_mystruct_3"
  ],
  "timespec *": [
   "0x15d8b_mystruct_1",
   "0x15ef5_mystruct_1",
   "0x16021_mystruct_1",
   "0x16694_mystruct_1"
  ],
  "__va_list_tag *": [
   "0x16fd9_mystruct_1"
  ],
  "FILE *": [
   "0x1779a_mystruct_1"
  ],
  "randint_source *": [
   "0x1819e_mystruct_1",
   "0x18257_mystruct_1"
  ],
  "randread_source *": [
   "0x18524_mystruct_1",
   "0x187ef_mystruct_1",
   "0x187ef_mystruct_1",
   "0x188e2_mystruct_1",
   "0x18901_mystruct_1",
   "0x18920_mystruct_1"
  ],
  "isaac_state *": [
   "0x18c13_mystruct_1",
   "0x18c13_mystruct_3",
   "0x19368_mystruct_1"
  ]
 },
 "answer": {
  "0x1246c": {
   "mem1_0": "char",
   "mem1_2": "char",
   "mem1_1": "char"
  },
  "0x19368": {
   "mem1_32": "qword",
   "mem1_24": "qword",
   "mem1_40": "qword",
   "mem1_8": "qword",
   "mem1_56": "qword",
   "mem1_2056": "qword",
   "mem1_0": "qword",
   "mem1_2064": "qword",
   "mem1_48": "qword",
   "mem1_16": "qword",
   "mem1_2048": "qword"
  }
 }
}